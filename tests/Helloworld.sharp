mod application;

/**
 * Created by BraxtonN on 1/22/2018.
 */
class Helloworld {
    def foo() : var {
        for(var i = 0; i < 10; i++) {
            System.print(i);
        }
    }
}

#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }
#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }
#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }
#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }
#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }
#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }
#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }
#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }
#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }
#include <string.h>
#include <string>
#include <sstream>
#include <cstdio>
#include "runtime.h"
#include "../util/file.h"
#include "../runtime/interp/Opcode.h"
#include "../runtime/interp/register.h"
#include "Asm.h"
#include "../util/List2.h"
#include "../runtime/internal/Exe.h"
#include "../runtime/oo/Object.h"
#include "Optimizer.h"

using namespace std;

options c_options;
_operator string_toop(string op);

unsigned int runtime::classUID = 0;

void runtime::interpret() {

    if(partial_parse()) {

        resolveAllFields();
        resolveAllMethods();

        if(c_options.magic) {
            List<string> lst;
            lst.addAll(modules);

            for(parser* p : parsers) {
                bool found = false;

                for(unsigned int i = 0; i < import_map.size(); i++) {
                    if(import_map.get(i).key == p->sourcefile) {
                        import_map.get(i).value.addAll(modules);
                        found = true;
                        break;
                    }
                }

                if(!found) {
                    import_map.add(keypair<std::string, List<std::string>>(p->sourcefile, lst));
                }
            }

            lst.free();
        }

        long iter =0;   // TODO: parse new var[] { 1, 2, 3, 4 }; and " hi " + 8 (string concatanation)
        for(parser* p : parsers) {
            errors = new Errors(p->lines, p->sourcefile, true, c_options.aggressive_errors);
            _current = p;
            iter++;

            current_module = "";

            ast* trunk;
            add_scope(Scope(scope_global, NULL));
            for(size_t i = 0; i < p->treesize(); i++) {
                trunk = p->ast_at(i);

                switch(trunk->gettype()) {
                    case ast_module_decl:
                        current_module = parse_modulename(trunk);
                        break;
                    case ast_import_decl:
                        parse_import_decl(trunk);
                        break;
                    case ast_class_decl:
                        parse_class_decl(trunk);
                        break;
                    case ast_macros_decl:
                        parseMacrosDecl(trunk);
                        break;
                    default:
                        stringstream err;
                        err << ": unknown ast type: " << trunk->gettype();
                        errors->newerror(INTERNAL_ERROR, trunk->line, trunk->col, err.str());
                        break;
                }
            }

            if(iter == parsers.size() && errors->error_count() == 0 && errors->uoerror_count() == 0) {
                getMainMethod(p);
            }

            if(errors->_errs()){
                errs+= errors->error_count();
                uo_errs+= errors->uoerror_count();
                parse_map.key.addif(p->sourcefile);
                parse_map.value.removefirst(p->sourcefile);
            } else {
                parse_map.value.addif(p->sourcefile);
                parse_map.key.removefirst(p->sourcefile);
            }

            remove_scope();
            errors->print_errors();
            errors->free();
            delete (errors); this->errors = NULL;
        }
    }
}

Method *runtime::getMainMethod(parser *p) {
    string starter_classname = "Start";

    ClassObject* StarterClass = getClass("application", starter_classname);
    if(StarterClass != NULL) {
        List<Param> params;
        List<AccessModifier> modifiers;
        RuntimeNote note = RuntimeNote(p->sourcefile, p->geterrors()->getline(1), 1, 0);
        params.add(Field(fvar, 0, "args", StarterClass, modifiers, note));
        params.get(0).field.array = true;
        params.get(0).field.type = field_native;

        Method* main = StarterClass->getFunction("__init" , params);

        if(main == NULL) {
            errors->newerror(GENERIC, 1, 0, "could not locate main method '__init(var[])' in starter class");
        } else
            runtime::main = main;
        return main;
    } else {
        errors->newerror(GENERIC, 1, 0, "Could not find starter class '" + starter_classname + "' for application entry point.");
        return NULL;
    }
}

ClassObject *runtime::parse_base_class(ast *pAst, int startpos) {
    Scope* scope = current_scope();
    ClassObject* klass=NULL;

    if(startpos >= pAst->getentitycount()) {
        return NULL;
    } else {
        ref_ptr ptr = parse_refrence_ptr(pAst->getsubast(ast_refrence_pointer));
        klass = resolve_class_refrence(pAst->getsubast(ast_refrence_pointer), ptr);

        if(klass != NULL) {
            if((scope->klass->getHeadClass() != NULL && scope->klass->getHeadClass()->curcular(klass)) ||
                    scope->klass->match(klass) || klass->match(scope->klass->getHeadClass())) {
                errors->newerror(GENERIC, pAst->getsubast(0)->line, pAst->getsubast(0)->col,
                                 "cyclic dependency of class `" + ptr.refname + "` in parent class `" + scope->klass->getName() + "`");
            }
        }
    }

    return klass;
}

void runtime::setHeadClass(ClassObject *klass) {
    ClassObject* sup = klass->getBaseClass();
    if(sup == NULL) {
        klass->setHead(klass);
        return;
    }
    while(true) {
        if(sup->getBaseClass() == NULL) {
            klass->setHead(sup);
            return;
        } else
            sup = sup->getBaseClass();
    }
}

/*
 * TODO: add this to parsing macros
 * if(element_has(modifiers, mStatic))
        warning(REDUNDANT_TOKEN, pAst->getentity(element_index(modifiers, mStatic)).getline(),
                pAst->getentity(element_index(modifiers, mStatic)).getcolumn(), " `static`, macros are static by default");
 */
void runtime::parse_class_decl(ast *pAst) {
    Scope* scope = current_scope();
    ast* trunk = pAst->getsubast(ast_block);
    list<AccessModifier> modifiers;
    ClassObject* klass;
    int startpos=1;

    parse_access_decl(pAst, modifiers, startpos);
    string className =  pAst->getentity(startpos).gettoken();

    if(scope->type == scope_global) {
        klass = getClass(current_module, className);

        setHeadClass(klass);
    }
    else {
        klass = scope->klass->getChildClass(className);

        klass->setSuperClass(scope->klass);
        setHeadClass(klass);
    }

    add_scope(Scope(scope_class, klass));
    for(long i = 0; i < trunk->getsubastcount(); i++) {
        pAst = trunk->getsubast(i);

        switch(pAst->gettype()) {
            case ast_class_decl:
                parse_class_decl(pAst);
                break;
            case ast_var_decl:
                parse_var_decl(pAst);
                break;
            case ast_method_decl:
                parseMethodDecl(pAst);
                break;
            case ast_operator_decl:
                parseOperatorDecl(pAst);
                break;
            case ast_construct_decl:
                parseConstructorDecl(pAst);
                break;
            case ast_macros_decl:
                parseMacrosDecl(pAst);
                break;
            default: {
                stringstream err;
                err << ": unknown ast type: " << pAst->gettype();
                errors->newerror(INTERNAL_ERROR, pAst->line, pAst->col, err.str());
                break;
            }
        }
    }

    remove_scope();
}

void runtime::parseReturnStatement(Block& block, ast* pAst) { // TODO: fix returnign of new
    Scope* scope = current_scope();
    Expression returnVal, value;
    scope->reachable=false;
    scope->last_statement=ast_return_stmnt;

    if(pAst->hassubast(ast_value)) {
        value = parse_value(pAst->getsubast(ast_value));
        if(!value._new)
            block.code.inject(block.code.__asm64.size(), value.code);

        switch(value.type) {
            case expression_var:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if (value.func) {
                        // TODO: pull value from function
                        if(value.utype.array) {
                            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        } else {
                            Expression out;
                            pushExpressionToRegisterNoInject(value, out, ebx);
                            block.code.inject(block.code.__asm64.size(), out.code);
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                        }
                    } else {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                }
                break;
            case expression_field:
                if(value.utype.field->nativeInt() && !value.utype.field->array) {
                    if(value.utype.field->local) {
                        Expression out;
                        pushExpressionToRegisterNoInject(value, out, ebx);
                        block.code.inject(block.code.__asm64.size(), out.code);
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    } else {
                        block.code.push_i64(SET_Di(i64, op_MOVI, 0), adx);
                        block.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, adx));

                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, -5));
                    }
                } else if(value.utype.field->nativeInt() && value.utype.field->array) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                } else if(value.utype.field->dynamicObject() || value.utype.field->type == field_class) {
                    if(value.utype.field->local) {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                    }
                }
                break;
            case expression_lclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    }
                }
                break;
            case expression_string:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Di(i64, op_NEWSTR, value.intValue));
                break;
            case expression_null:
                block.code.push_i64(SET_Di(i64, op_INC, sp));
                block.code.push_i64(SET_Di(i64, op_MOVSL, -5));
                block.code.push_i64(SET_Ei(i64, op_DEL));
                break;
            case expression_dynamicclass:
                if(value._new) {
                    block.code.inject(block.code.__asm64.size(), value.code);
                    block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                    block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                } else {
                    if(value.func) {
                        /* I think we do nothing? */
                        block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
                        block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                        block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                    } else {
                        if(value.utype.type == ResolvedReference::FIELD) {
                            if(value.utype.field->local) {
                                block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                                block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                            } else
                                block.code.push_i64(SET_Ei(i64, op_RETURNREF));
                        } else {
                            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
                            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
                        }
                    }
                }
                break;
        }
    } else {
        value.type = expression_void;
        if(scope->function->constructor) {
            block.code.push_i64(SET_Di(i64, op_MOVSL, 0));
            block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, fp));
            block.code.push_i64(SET_Di(i64, op_SMOVOBJ, -5));
        }
    }


    block.code.push_i64(SET_Ei(i64, op_RET));
    returnVal.type = methodReturntypeToExpressionType(scope->function);
    if(returnVal.type == expression_lclass) {
        returnVal.utype.klass = scope->function->klass;
        returnVal.utype.type = ResolvedReference::CLASS;
    }
    returnVal.utype.array = scope->function->array;
    equals(returnVal, value, ": Returning `" + value.typeToString() + "` from a function returning `" + returnVal.typeToString() + "`");
}

void runtime::parseIfStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, out;
    cond = parseExpression(pAst->getsubast(ast_expression));

    string ifEndLabel;
    stringstream ss;
    ss << generic_label_id << scope->ulid;
    ifEndLabel=ss.str();

    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    if(pAst->getsubastcount() > 2) {
        int64_t insertAddr, difference;
        block.code.push_i64(SET_Di(i64, op_LOADX, adx));
        insertAddr=block.code.size();
        block.code.push_i64(0);
        block.code.push_i64(0);
        parseBlock(pAst->getsubast(ast_block), block);
        difference = block.code.size()-insertAddr;

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }

        block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
        block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

        scope->addBranch(ifEndLabel, 1, block.code, pAst->getsubast(ast_expression)->line,
                         pAst->getsubast(ast_expression)->col);

        ast* trunk;
        for(unsigned int i = 2; i < pAst->getsubastcount(); i++) {
            trunk = pAst->getsubast(i);
            switch(trunk->gettype()) {
                case ast_elseif_statement:
                    cond = parseExpression(trunk->getsubast(ast_expression));

                    out.free();
                    pushExpressionToRegister(cond, out, cmt);
                    block.code.inject(block.code.size(), out.code);

                    block.code.push_i64(SET_Di(i64, op_LOADX, adx));
                    insertAddr=block.code.size();
                    block.code.push_i64(0);
                    block.code.push_i64(0);
                    parseBlock(trunk->getsubast(ast_block), block);
                    difference = block.code.size()-insertAddr;

                    if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                             || scope->last_statement == ast_throw_statement)) {
                        scope->reachable=true;
                    }

                    block.code.__asm64.replace(insertAddr++, SET_Ci(i64, op_IADD, adx,0, (difference+2)));
                    block.code.__asm64.replace(insertAddr, SET_Ei(i64, op_IFNE));

                    scope->addBranch(ifEndLabel, 1, block.code, trunk->getsubast(ast_expression)->line,
                                     trunk->getsubast(ast_expression)->col);
                    break;
                case ast_else_statement:
                    parseBlock(trunk->getsubast(ast_block), block);
                    break;
            }
        }
    } else {
        scope->addStore(ifEndLabel, adx, 1, block.code, pAst->getsubast(ast_expression)->line,
                        pAst->getsubast(ast_expression)->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
        parseBlock(pAst->getsubast(ast_block), block);

        if(!scope->reachable && (scope->last_statement==ast_return_stmnt
                                 || scope->last_statement == ast_throw_statement)) {
            scope->reachable=true;
        }
    }


    scope->label_map.add(keypair<string,int64_t>(ifEndLabel, __init_label_address(block.code)));
}

void runtime::parseAssemblyBlock(Block& block, ast* pAst) {
    string assembly = "";

    if(pAst->getentitycount() == 1) {
        if(file::exists(pAst->getentity(0).gettoken().c_str())) {
            file::buffer __ostream;
            file::read_alltext(pAst->getentity(0).gettoken().c_str(), __ostream);

            assembly = __ostream.to_str();
            __ostream.end();
        } else {
            assembly = pAst->getentity(0).gettoken();
        }
    } else {
        for(unsigned int i = 0; i < pAst->getentitycount(); i++) {
            assembly += pAst->getentity(i).gettoken() + "\n";
        }
    }

    Asm __vasm;
    __vasm.parse(block.code, this, assembly, pAst);
}

void runtime::parseAssemblyStatement(Block& block, ast* pAst) {
    if(c_options.unsafe)
        parseAssemblyBlock(block, pAst->getsubast(ast_assembly_block));
    else
        errors->newerror(GENERIC, pAst, "calling __asm without unsafe mode enabled. try recompiling your code with [-unsafe]");
}

bool runtime::validateLocalField(std::string name, ast* pAst) {
    Scope* scope = current_scope();
    keypair<int, Field>* field;

    if((field = scope->getLocalField(name)) != NULL) {
        if(scope->blocks == field->key) {
            // err redefinition of parameter
            errors->newerror(DUPlICATE_DECLIRATION, pAst, " local variable `" + field->value.name + "`");
            return false;
        } else {
            warning(GENERIC, pAst->line, pAst->col, " local variable `" + field->value.name + "` hides previous declaration in higher scope");
            return true;
        }
    } else {
        return true;
    }
}

Field runtime::utypeArgToField(keypair<string, ResolvedReference> arg) {
    Field field;
    field.name = arg.key;
    field.array = arg.value.array;
    field.fullName = field.name;
    field.klass = arg.value.klass;
    field.modifiers.add(mPublic);
    field.nf = arg.value.nf;
    if(arg.value.type == ResolvedReference::CLASS) {
        field.type = field_class;
    } else if(arg.value.type == ResolvedReference::NATIVE) {
        field.type = field_native;
    } else {
        field.type = field_unresolved;
    }

    return field;
}

void runtime::removeForLabels(Scope* scope) {
    readjust:
    for(long long i = 0; i < scope->label_map.size(); i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            scope->label_map.remove(i);
            goto readjust;
        }
    }
}

void runtime::parseForStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    Expression cond, iter;
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    stringstream ss;
    string forEndLabel, forBeginLabel;

    parseUtypeArg(pAst, scope, block);

    ss.str("");
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    if(pAst->hassubast(ast_for_expresion_cond)) {
        Expression out;
        cond = parseExpression(pAst->getsubast(ast_for_expresion_cond));

        pushExpressionToRegister(cond, out, cmt);
        block.code.inject(block.code.size(), out.code);

        scope->addStore(forEndLabel, adx, 1, block.code, pAst->line, pAst->col);
        block.code.push_i64(SET_Ei(i64, op_IFNE));
    }

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    if(pAst->hassubast(ast_for_expresion_iter)) {
        iter = parseExpression(pAst->getsubast(ast_for_expresion_iter));
        block.code.inject(block.code.size(), iter.code);
    }

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    scope->remove_locals(scope->blocks);
    scope->blocks--;
    scope->loops--;
}

void runtime::parseUtypeArg(ast *pAst, Scope *scope, Block &block, Expression* comparator) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression value, out;

        if(pAst->hassubast(ast_value)) {
            if(comparator != NULL)
                errors->newerror(UNEXPECTED_SYMBOL, pAst->getsubast(ast_value), " `;` expected");
            value = parse_value(pAst->getsubast(ast_value));
        }

        if(validateLocalField(utypeArg.key, pAst->getsubast(ast_utype_arg))) {
            if(utypeArg.value.type == ResolvedReference::FIELD) {
                errors->newerror(COULD_NOT_RESOLVE, pAst->getsubast(ast_utype_arg), " `" + utypeArg.value.field->name + "`");
            }

            keypair<int, Field> local;
            local.set(scope->blocks, utypeArgToField(utypeArg));
            local.value.vaddr = scope->function->local_count++;;
            local.value.local=true;
            scope->locals.push_back(local);

            Expression fieldExpr = fieldToExpression(pAst, local.value);

            if(value.type != expression_unknown) {
                equals(fieldExpr, value);

                token_entity operand("=", SINGLE, 0,0, ASSIGN);
                assignValue(operand, out, fieldExpr, value, pAst);
                block.code.inject(block.code.size(), out.code);
            }
        }
    }
}

void runtime::assignUtypeForeach(ast *pAst, Scope *scope, Block &block, Expression& assignExpr) {
    if(pAst->hassubast(ast_utype_arg)) {
        keypair<string, ResolvedReference> utypeArg = parseUtypeArg(pAst->getsubast(ast_utype_arg));
        Expression out;

        keypair<int, Field>* local = scope->getLocalField(utypeArg.key);
        Expression fieldExpr = fieldToExpression(pAst, local->value);

        token_entity operand("=", SINGLE, 0,0, ASSIGN);
        assignValue(operand, out, fieldExpr, assignExpr, pAst);
        block.code.inject(block.code.size(), out.code);
    }
}

Expression runtime::fieldToExpression(ast *pAst, string name) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);
    keypair<int, Field>* field;

    if((field =scope->getLocalField(name)) == NULL)
        return fieldExpr;

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field->value;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field->value.name;
    return fieldExpr;
}

Expression runtime::fieldToExpression(ast *pAst, Field& field) {
    Scope* scope=current_scope();
    Expression fieldExpr(pAst);

    fieldExpr.type = expression_field;
    fieldExpr.utype.field = &field;
    fieldExpr.utype.type = ResolvedReference::FIELD;
    fieldExpr.utype.refrenceName = field.name;

    if(field.isObjectInMemory()) {
        fieldExpr.code.push_i64(SET_Di(i64, op_MOVL, field.vaddr));
    } else {
        fieldExpr.code.push_i64(SET_Ci(i64, op_MOVR, adx, 0, fp));
        fieldExpr.code.push_i64(SET_Ci(i64, op_SMOV, ebx, 0, field.vaddr));
    }
    return fieldExpr;
}

void runtime::getArrayValueOfExpression(Expression& expr, Expression& out) {
    switch(expr.type) {
        case expression_var:
            out.type=expression_var;
            out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            break;
        case expression_lclass:
            out.type=expression_lclass;
            out.utype.klass = expr.utype.klass;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
        case expression_field:
            if(expr.utype.field->nativeInt()) {
                out.type=expression_var;
                out.code.push_i64(SET_Ci(i64, op_MOVX, ebx,0, ebx));
            }
            else {
                out.type=expression_lclass;
                out.utype.klass = expr.utype.field->klass;
                out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            }
            break;
        default:
            out=expr;
            out.code.push_i64(SET_Di(i64, op_MOVND, ebx));
            break;
    }
}

void runtime::parseForEachStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    scope->blocks++;
    scope->loops++;
    scope->ulid++;
    string forBeginLabel, forEndLabel;

    Expression arryExpression(parseExpression(pAst->getsubast(ast_expression))), out;
    parseUtypeArg(pAst, scope, block, &arryExpression);

    /*
     * This is stupid but we do this so we dont mess up the refrence with out local array expression variable
     */
    arryExpression = parseExpression(pAst->getsubast(ast_expression));

    block.code.push_i64(SET_Di(i64, op_MOVI, 0), ebx);
    block.code.push_i64(SET_Di(i64, op_PUSHR, ebx));

    if(!arryExpression.arrayObject()) {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must evaluate to type array");
    }

    stringstream ss;
    ss << for_label_begin_id << scope->ulid;
    forBeginLabel=ss.str();

    ss.str("");
    ss << for_label_end_id << scope->ulid;
    forEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(forBeginLabel,__init_label_address(block.code)));

    block.code.inject(block.code.size(), arryExpression.code);

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_SIZEOF, egx));
    block.code.push_i64(SET_Ci(i64, op_LT, ebx,0, egx));
    scope->addStore(forEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_block)->line, pAst->getsubast(ast_block)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));
    getArrayValueOfExpression(arryExpression, out);
    assignUtypeForeach(pAst, scope, block, out);

    parseBlock(pAst->getsubast(ast_block), block);

    if(!scope->reachable && scope->last_statement==ast_return_stmnt) {
        scope->reachable=true;
    }

    block.code.push_i64(SET_Ci(i64, op_MOVR, adx,0, sp));
    block.code.push_i64(SET_Ci(i64, op_SMOV, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_INC, ebx));
    block.code.push_i64(SET_Ci(i64, op_SMOVR, ebx,0, 0));
    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(forBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(forEndLabel,__init_label_address(block.code)));
    block.code.push_i64(SET_Ei(i64, op_POP));

    scope->remove_locals(scope->blocks);
    scope->loops--;
    scope->blocks--;
}

void runtime::parseWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel, whileEndLabel;

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();

    ss.str("");
    ss << generic_label_id << ++scope->ulid;
    whileEndLabel=ss.str();

    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);

    scope->addStore(whileEndLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFNE));

    parseBlock(pAst->getsubast(ast_block), block);

    block.code.push_i64(SET_Di(i64, op_GOTO, (get_label(whileBeginLabel)+1)));
    scope->label_map.add(keypair<std::string, int64_t>(whileEndLabel,__init_label_address(block.code)));
}

void runtime::parseDoWhileStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    string whileBeginLabel;

    stringstream ss;
    ss << generic_label_id << ++scope->ulid;
    whileBeginLabel=ss.str();
    scope->label_map.add(keypair<std::string, int64_t>(whileBeginLabel,__init_label_address(block.code)));

    parseBlock(pAst->getsubast(ast_block), block);

    Expression cond = parseExpression(pAst->getsubast(ast_expression)), out;
    pushExpressionToRegister(cond, out, cmt);
    block.code.inject(block.code.size(), out.code);


    scope->addStore(whileBeginLabel, adx, 1, block.code,
                    pAst->getsubast(ast_expression)->line, pAst->getsubast(ast_expression)->col);
    block.code.push_i64(SET_Ei(i64, op_IFE));
}

ClassObject* runtime::parseCatchClause(Block &block, ast *pAst, ExceptionTable et) {
    Scope* scope = current_scope();
    ClassObject* klass = NULL;

    keypair<string, ResolvedReference> catcher = parseUtypeArg(pAst->getsubast(ast_utype_arg_opt));

    string name =  catcher.key;
    keypair<int, Field>* field;
    List<AccessModifier> modCompat;
    modCompat.add(mPublic);

    RuntimeNote note = RuntimeNote(_current->sourcefile, _current->geterrors()->getline(pAst->line),
                                   pAst->line, pAst->col);
    Field f = Field(NULL, uid++, name, scope->klass, modCompat, note);

    f.vaddr = scope->function->local_count;
    f.local=true;
    scope->function->local_count++;
    if(catcher.value.type == ResolvedReference::CLASS) {
        f.klass = catcher.value.klass;
        f.type = field_class;
    } else if(catcher.value.type == ResolvedReference::NATIVE) {
        errors->newerror(GENERIC, pAst, " field `" + catcher.value.field->name + "` is not a class");
        f.nf = catcher.value.nf;
        f.type = field_native;
    } else {
        f.type = field_unresolved;
    }

    f.array = catcher.value.array;

    if(validateLocalField(name, pAst)) {
        if(catcher.value.type == ResolvedReference::FIELD) {
            errors->newerror(COULD_NOT_RESOLVE, pAst, " `" + catcher.value.field->name + "`");
        }

        scope->locals.add(keypair<int, Field>(scope->blocks, f));
        field = scope->getLocalField(name);
        et.local = f.vaddr;
        et.klass = f.klass == NULL ? "" : f.klass->getFullName();
        klass=f.klass;
        et.handler_pc = __init_label_address(block.code)+1;
        scope->function->exceptions.push_back(et);
    }

    // TODO: add goto to finally block
    parseBlock(pAst->getsubast(ast_block), block);
    return klass;
}

void runtime::parseFinallyBlock(Block& block, ast* pAst) {
    current_scope()->reachable=true;
    parseBlock(pAst->getsubast(ast_block), block);
}

/*
 * TODO: create FinallyBlockTabel to contain startpc and end pc of block
 *
 * in return_asp() do a check to see if there are any finally blocks in this func, then
 * if there is execute the functions from the starting pc till end of func
 *
 * in thread class add variable called raisedPc
 *
 * if exception is caught execute last finally block from called pc to current pc
 * in finally block function have setup like
 *
 * execFinallyBlocks(bool executeAll) // ALLOW Interrupts and suspends
 *
 * finallyBlockTabel format
 * int64_t start_pc
 * int64_t end_pc
 *
 */
void runtime:: parseTryCatchStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();
    ExceptionTable et;
    scope->trys++;
    string catchEndLabel;
    List<ClassObject*> klasses;
    ClassObject* klass;

    et.start_pc = block.code.__asm64.size();
    parseBlock(pAst->getsubast(ast_block), block);
    et.end_pc = block.code.__asm64.size();

    if(pAst->hassubast(ast_catch_clause))
        scope->reachable=true;

    stringstream ss;
    ss << try_label_end_id << ++scope->ulid;
    catchEndLabel = ss.str();

    ast* sub;
    for(unsigned int i = 1; i < pAst->getsubastcount(); i++) {
        sub = pAst->getsubast(i);

        switch(sub->gettype()) {
            case ast_catch_clause:
                scope->blocks++;
                klass = parseCatchClause(block, sub, et);
                scope->addBranch(catchEndLabel, 1, block.code, sub->line, sub->col);

                if(klass != NULL) {
                    if(klasses.find(klass)) {
                        errors->newerror(GENERIC, sub, "exception `" + klass->getName() + "` has already been caught");
                    } else
                        klasses.add(klass);
                }

                scope->remove_locals(scope->blocks);
                scope->blocks--;
                break;
            case ast_finally_block:
                break;
        }
    }

    block.code.push_i64(SET_Ei(i64, op_NOP)); // for allignment
    block.code.push_i64(SET_Ei(i64, op_NOP));

    klasses.free();
    scope->label_map.add(keypair<string,int64_t>(catchEndLabel, __init_label_address(block.code)));

    if(pAst->hassubast(ast_finally_block)) {
        FinallyTable ft;
        ft.start_pc=__init_label_address(block.code);
        parseFinallyBlock(block, pAst->getsubast(ast_finally_block));
        ft.end_pc=__init_label_address(block.code);

        scope->function->finallyBlocks.push_back(ft);

    }
    scope->trys--;
}

void runtime::parseThrowStatement(Block& block, ast* pAst) {
    Expression clause = parseExpression(pAst->getsubast(ast_expression)), out;
    current_scope()->reachable=false;
    current_scope()->last_statement=ast_throw_statement;

    if(clause.type == expression_lclass) {
        ClassObject* throwable = getClass("std.err", "Throwable");

        if(throwable != NULL) {
            if(clause.utype.klass->hasBaseClass(throwable)) {
                pushExpressionToStack(clause, out);

                out.code.push_i64(SET_Ei(i64, op_THROW));
                block.code.inject(block.code.size(), out.code);
            } else {
                errors->newerror(GENERIC, pAst->getsubast(ast_expression), "class `" + clause.utype.klass->getFullName() +
                    "` does not inherit `std.err#Throwable`");
            }
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "missing core class `std.err#Throwable` for exception handling");
        }
    } else if(clause.type == expression_field) {
        if(clause.utype.field->type == field_class) {
            pushExpressionToStack(clause, out);

            out.code.push_i64(SET_Ei(i64, op_THROW));
            block.code.inject(block.code.size(), out.code);
        } else {
            errors->newerror(GENERIC, pAst->getsubast(ast_expression), "field `" + clause.utype.field->name +
                                                                       "` is not a class");
        }
    } else
     {
        errors->newerror(GENERIC, pAst->getsubast(ast_expression), "expression must be of type lclass");
     }
}

int64_t runtime::getLastLoopBeginAddress() {
    Scope* scope = current_scope();

    for(long long i = scope->label_map.size()-1; i < 0; i++) {
        if(scope->label_map.get(i).key == for_label_begin_id) {
            return scope->label_map.get(i).value;
        }
    }

    return -1;
}

void runtime::parseContinueStatement(Block& block, ast* pAst) {
    Scope* scope = current_scope();

    if(scope->loops > 0) {
        stringstream name;
        name << for_label_begin_id << scope->loops;
        scope->addBranch(name.str(), 0, block.code, pAst->line, pAst->col);
    } else {
        // error not in loop
        errors->newerror(GENERIC, pAst, "continue statement outside of loop");
    }
}

bool runtime::label_exists(string label) {
    for(unsigned int i = 0; i < current_scope()->label_map.size(); i++) {
        if(current_scope()->label_map.get(i).key == label)
            return true;
    }

