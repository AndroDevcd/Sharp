mod std.io;

import std;
import std.kernel.vm;

/**
 * Created by BraxtonN on 6/4/2018.
 */
public class Thread {

    public Thread(string name, fn main (object[]) : var) {
        self->main = main;
        self->name = name;
        self->stackSize = DEFAULT_STACK_SIZE;
        self->id = ThreadCore.__thread_create(self);

        addThread(self);
    }

    public Thread(string name, fn main (object[]) : var, var stackSize) {
        self->main = main;
        self->name = name;
        self->stackSize = stackSize;
        self->id = ThreadCore.__thread_create(self);

        addThread(self);
    }

    public def start(object[] args) : var {
        return ThreadCore.__thread_start(self, args);
    }

    public def join() : var {
        return ThreadCore.__thread_join(self);
    }

    public def interrupt() : var {
        return ThreadCore.__thread_interrupt(self);
    }

    public def destroy() : var {
        return ThreadCore.__thread_destroy(self);
    }

    public static def currentThread() : Thread {
        return ThreadCore.__thread_current();
    }

    static ArrayList<Thread> pool = new ArrayList<Thread>();
    static var DEFAULT_STACK_SIZE = 0xcfba;

    static def addThread(Thread thread) {
        lock(pool) {
            pool.add(thread);
        }
    }

    static def popThread(Thread thread) {
        lock(pool) {
            Thread[] lst = pool.toArray();
            var iter;
            foreach(Thread t : lst) {
                if(thread.id == t.id) {
                    pool.remove(iter);
                    break;
                }
                iter++;
            }
        }
    }

    public def getId() : var { return id; }
    public def getStackSize() : var { return stackSize; }
    public def getName() : string { return name; }
    public def setExited(var exited) { self->exited = exited; }
    public def isExited() : var { return exited; }
    public def isDaemon() : var { return daemon; }
    public def setStarted(var started) { self->started = started; }
    public def isStarted() : var { return started; }
    public def setTerminated(var term) { self->terminated = term; }
    public def isTerminated() : var { return terminated; }

    public static def setupMainThread() {
        Thread main = new Thread();
        main.main = global#__SRT_Global.main;
        main.id = 0;
        main.name = "main";
        main.started = true;
        main.stackSize = DEFAULT_STACK_SIZE;

        addThread(main);
        ThreadCore.__thread_set_thread(main); // set current thread to main
    }

    public var exitCode;

    //protected ThreadLocal<?>.ThreadLocalMap map;
    var id;
    var daemon; // not supported as of now
    var terminated;
    var exited;
    string name = "";
    var started;
    var stackSize;
    fn main (object[]) : var;
}
