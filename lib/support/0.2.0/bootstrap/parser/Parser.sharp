mod app;

import std;

/**                          
* Created by bknun on 7/5/2018            
* Description:                             
*/
class Parser {
    public Parser(Tokenizer tokenizer)
    {
        self->tokenizer=tokenizer;

        if(tokenizer != null && tokenizer.getErrors() != null
            && !tokenizer.getErrors().hasErrors())
        {
            data = tokenizer.getData();
            accessTypes = new ArrayList<TokenEntity>();
            tree = new ArrayList<Ast>();
            states = new Dictionary<var, Ast>();
            lines = tokenizer.getLines();

            parse();
        }
    }

    private def parse() {
        sourceFile = tokenizer.getFile();
        errors = new ErrorManager(lines, sourceFile, true, Options.aggressiveErrors);
        current = tokenizer.get(cursor);


        while (!isEnd())
        {
            if(panic)
                break;

            if(isAccessType(current))
                parseAccessTypes();

            if(quit()) break;

            if(isEnd()) {
                accessTypes.clear();
                return;
            } else if(isDecl(current, MOD)) {
                if(accessTypes.size() > 0)
                    errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");
                parseModuleDecl(null);
            } else if(isDecl(current, CLASS)) {
                parseClassDecl(null);
            }

            advance();
        }
    }

    private def parseClassDecl(Ast ast) {
        ast = getAst(ast, AstType.Class_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }

        ast.add(current);
        expectIdentifier(ast);

        if(peek(1).getToken() == "<") {
            ast.setType(AstType.Generic_Class_Decl);

            expect(TokenType.LESSTHAN, "`<`");
            parseIdentifierList(ast);
            expect(TokenType.GREATERTHAN, "`>`");
        }

        if(peek(1).getToken() == "base") {
            advance();
            expectToken(ast, "base");
            parseReferencePointer(ast);
        }

        if(peek(1).getToken() == ":") {
            expect(TokenType.COLON, "`:`");
            parseRefrenceIdentifierList(ast);
        }

        parseClassBlock(ast);
    }

    private def parseClassBlock(Ast ast) {
        expect(TokenType.LEFT_CURLY, "`{` after class decliration");
        ast = getAst(ast, AstType.Class_Decl);

        var brackets = 1;
        while(!isEnd() && brackets > 0) {
            if(quit()) break;

            advance();
            if(isAccessType(current))
                parseAccessTypes();

            if(isDecl(current, MOD)) {
                if(accessTypes.size() > 0)
                     errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");

                errors.createNewError(CompilerError.GENERIC, current, "unexpected module declaration");
                parseModuleDecl(ast);
            } else if(isDecl(current, CLASS)) {
                parseClassDecl(ast);
            } else if(isDecl(current, INTERFACE)) {
                parseInterfaceDecl(ast);
            }
        }
    }

    private def parseInterfaceDecl(Ast ast) {
        ast = getAst(ast, AstType.Interface_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }

        ast.add(current);
        expectIdentifier(ast);

        if(peek(1).getToken() == "<") {
            ast.setType(AstType.Generic_Interface_Decl);

            expect(TokenType.LESSTHAN, "`<`");
            parseIdentifierList(ast);
            expect(TokenType.GREATERTHAN, "`>`");
        }

        if(peek(1).getToken() == "base")
        {
            advance();
            expectToken(ast, "base");
            parseReferencePointer(ast);
        }

        parseInterfaceBlock(ast);
    }

    private def parseInterfaceBlock(Ast ast) {
        expect(TokenType.LEFT_CURLY, "`{` after interface declaration");
        ast = getAst(ast, AstType.Block);

        var brackets = 1;
        while(!isEnd() && brackets > 0) {
            if(quit()) break;

            advance();

            if(isAccessType(current))
                parseAccessTypes();

            if(isDecl(current, MOD)) {
                if(accessTypes.size() > 0)
                     errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");

                errors.createNewError(CompilerError.GENERIC, current, "unexpected module declaration");
                parseModuleDecl(ast);
            } else if(isDecl(current, INTERFACE)) {
                parseInterfaceDecl(ast);
            } else if(isDecl(current, IMPORT)) {
                 if(accessTypes.size() > 0)
                      errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");

                 errors.createNewError(CompilerError.GENERIC, current, "unexpected import declaration");
                 parseImportDecl(ast);
            } else if(isDecl(current, VAR) || isDecl(current, OBJECT)) {
                 if(accessTypes.size() > 0)
                      errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");

                 errors.createNewError(CompilerError.GENERIC, current, "unexpected variable declaration");
                 parseVariableDecl(ast);
            } else if(isDecl(current, PROTOTYPE)) {
                 if(accessTypes.size() > 0)
                      errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");

                 errors.createNewError(CompilerError.GENERIC, current, "unexpected prototype declaration");
                 parseProtoTypeDecl(ast, false);
            }else if(isDecl(current, METHOD))
            {
                if(peek(1).getToken() == "operator") {
                    if(accessTypes.size() > 0)
                    {
                        errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");
                    }
                    errors.createNewError(CompilerError.GENERIC, current, "unexpected operator declaration");
                    parseOperatorDecl(ast);
                }
                else if(peek(1).getToken() == "delegate") {
                    parseDelegateDecl(ast);
                }
                else {
                    if(accessTypes.size() > 0)
                    {
                        errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");
                    }
                    errors.createNewError(CompilerError.GENERIC, current, "unexpected method declaration");
                    parseMethodDecl(ast);
                }
            }
            else if(isConstructorDecl())
            {
                if(accessTypes.size() > 0)
                {
                    errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");
                }
                errors.createNewError(CompilerError.GENERIC, current, "unexpected constructor declaration");
                parseConstructor(ast);
            }
            else if(current.getType() == TokenType._EOF)
            {
                errors.createNewError(CompilerError.UNEXPECTED_EOF, current, "");
                break;
            }
            else if (current.getType() == TokenType.RIGHT_CURLY)
            {
                if((brackets-1) < 0)
                {
                    errors.createNewError(CompilerError.ILLEGAL_BRACKET_MISMATCH, current, "");
                }
                else
                {
                    brackets--;

                    // end of class block
                    if(brackets == 0)
                    {
                        pushBack();
                        break;
                    }
                }
            }
            else if(current.getType() == TokenType.LEFT_CURLY)
                brackets++;
            else {
                // save parser state
                retain(ast);
                pushBack();

                /*
                 * variable decl?
                 */
                if(parseUtype(ast))
                {
                    if(peek(1).getId() == TokenId.IDENTIFIER)
                    {
                        // Variable decliration
                        rollbackLast(ast);
                        parseVariableDecl(ast);
                        accessTypes.clear();
                        continue;
                    }
                }

                rollback(ast);
                errors.createNewError(CompilerError.GENERIC, current, "expected delegate prototype declaration");
                parseAll(ast);
            }

            accessTypes.clear();
        }

        if(brackets != 0)
            errors.createNewError(CompilerError.MISSING_BRACKET, current, " expected `}` at end of interface declaration");

        expect(TokenType.RIGHT_CURLY, "`}` at end of interface declaration");
    }

    private def isConstructorDecl() : var {
        return current.getId() == TokenId.IDENTIFIER && !isKeyword(current.getToken()) &&
                   peek(1).getType() == TokenType.LEFT_PAREN;
    }

    private def parseConstructor(Ast ast) {
        ast = getAst(ast, AstType.Constructor_Decl);

        for(var i = 0; i < accessTypes.size(); i++) {
            ast.add(accessTypes.get(i));
        }
        accessTypes.clear();
        pushBack();

        expectIdentifier(ast);

        parseUtypeArgList(ast);
        parseBlock(ast);
    }

    private def parseMethodDecl(Ast ast) {
        ast = getAst(ast, AstType.Method_Decl);

        for(int i = 0; i < accessTypes.size(); i++) {
            ast.add(accessTypes.get(i));
        }
        accessTypes.clear();
        ast.add(current);

        expectIdentifier(ast);

        parseUtypeList(ast);

        parseMethodReturnType(ast);
        parseBlock(ast);
    }

    private def parseDelegateDecl(Ast ast) {
        ast = getAst(ast, AstType.Delegate_Decl);

        for(var i = 0; i < accessTypes.size(); i++) {
            ast.add(accessTypes.get(i));
        }
        accessTypes.clear();
        ast.add(current);

        advance();
        expectToken(
                ast, "delegate", "`delegate`");

        expect(TokenType.COLON, ast, "`:`");
        expect(TokenType.COLON, ast, "`:`");
        expectIdentifier(ast);

        parseUtypeArgList(ast);
        parseMethodReturnType(ast); // assign-expr operators must return void
        if(peek(1).getType() == TokenType.LEFT_CURLY)
        {
            parseBlock(ast);
        } else {
            expect(TokenType.SEMICOLON, ast, "`;`");
            ast.setType(AstType.Delegate_Post_Decl);
        }
    }

    private def parseOperatorDecl(Ast ast) {
        ast = getAst(ast, AstType.Operator_Decl);

        for(var i = 0; i < accessTypes.size(); i++) {
            ast.add(accessTypes.get(i));
        }
        accessTypes.clear();
        ast.add(current);

        advance();
        expectToken(
                ast, "operator", "`operator`");

        advance();
        if(!isOverrideOperator(current.getToken()))
            errors.createNewError(GENERIC, current, "expected override operator");
        else
            ast.add(current);

        parseUtypeArgList(ast);
        parseMethodReturnType(ast); // assign-expr operators must return void

        parseBlock(ast);
    }

    private def parseProtoTypeDecl(Ast ast, var semicolon) {
        ast = getAst(ast, AstType.Func_Prototype);

        for(var i = 0; i < accessTypes.size(); i++) {
            ast.add(accessTypes.get(i));
        }
        accessTypes.clear();

        if(ast.tokenSize()>0)
            pushBack();

        if(!isDecl(current, PROTOTYPE))
            advance();
        expectToken(
                ast, "fn", "`fn`");

        expectIdentifier(ast);

        parseUtypeListOpt(ast);
        parseMethodReturnType(ast); // assign-expr operators must return void
        parserProtoTypeValueAssignment(ast);

        if(semicolon)
            expect(TokenType.SEMICOLON, "`;`");
    }

    private def parserProtoTypeValueAssignment(Ast ast) {
        advance();
        if(isOverrideOperator(current.getToken()))
        {
            if(current.getToken() != "=") {
                errors.createNewError(CompilerError.GENERIC, current, "expected assign operator `=`");
            }
            ast.add(current);
            parseValue(ast);
        }
        else
            pushBack();
    }

    private def parseMethodReturnType(Ast ast) {
        if(peek(1).getType() == TokenType.COLON)
        {
            ast = getAst(ast, AstType.Method_Return_Type);
            advance();

            ast.add(current);
            parseUtype(ast);
        }
    }

    private def parseImportDecl(Ast ast) {
        ast = getAst(ast, AstType.Import_Decl);
        ast.add(current);

        bool generic = false;
        parseModuleName(ast, generic);

        if(generic.getValue())
            errors.createNewError(CompilerError.GENERIC, current, "module-name does not allow for generic typing ");

        expect(TokenType.SEMICOLON, ast, "`;`");
    }

    var partialDecl = 0;
    private def parseVariableDecl(Ast ast) {
        ast = getAst(ast, AstType.Var_Decl);

        if(partialDecl == 0) {
            TokenEntity[] arry = accessTypes.toArray();
            foreach(TokenEntity token : arry) {
                ast.add(token);
            }

            accessTypes.clear();
            pushBack();
            if(!parseUtype(ast))
                errors.createNewError(CompilerError.GENERIC, current, "expected native type or reference pointer");

        } else
            partialDecl--;

        expectIdentifier(ast);
        parseValueAssignment(ast);

        if(peek(1).getType() == TokenType.COMMA) {
            partialDecl++;
            expect(TokenType.COMMA, "`,`");

            parseVariableDecl(partialDecl <= 1 ? ast : ast.getParent());
        } else if(partialDecl == 0)
            expect(TokenType.SEMICOLON, "`;`");
    }

    private def parseValueAssignment(Ast ast) {
        advance();
        if(isAssignOperator(current.getToken())) {
            ast.add(current);
            parseValue(ast);
        }
        else
            pushBack();
    }

    private def parseValue(Ast ast) : var {
        ast = getAst(ast, AstType.Value);
        return parseExpression(ast);
    }

    private def parseExpression(Ast ast) : var {
        ast = getAst(ast, AstType.Expression);
        if(quit()) return false;

        if(peek(1).getType() == TokenType._INC
            || peek(1).getType() == TokenType._DEC) {
            advance();
            ast.add(current);
            parseExpression(ast);
            ast.encapsulate(AstType.Pre_Inc_E);
            return true;
        }

        if(peek(1).getType() == TokenType.LEFT_CURLY) {
            parseVectorArray(ast);
            ast.encapsulate(AstType.Vect_E);
            return true;
        }

        retain(ast);
        if(parsePrimaryExpression(ast)) {
            dump();
            return true;
        } else {
            rollbackLast(ast);
        }

        if(isOverrideOperator(peek(1).getToken())) {
            advance();
            ast.add(current);

            parseExpression(ast);
            ast.encapsulate(AstType.Assign_E);

            if(!isOverrideOperator(peek(1).getToken()))
                return true;
        }

        var parsed = binary(ast);

        /* expression '?' expression ':' expression */
        if(peek(1).getType() == TokenType.QUESMK)
        {
            advance();
            ast.add(current);

            parseExpression(ast);

            expect(TokenType.COLON, ast, "`:`");

            parseExpression(ast);
            ast.encapsulate(AstType.Ques_E);
            return true;
        }

        return parsed;
    }

    private def binary(Ast ast) : var {
        var parsed = shift(ast);

        while(peek(1).getType() == TokenType.AND || peek(1).getType() == TokenType.XOR
            || peek(1).getType() == TokenType.OR || peek(1).getType() == TokenType.ANDAND
            || peek(1).getType() == TokenType.OROR) {
            advance();
            ast.add(current);

            shift(ast);
            ast.encapsulate(AstType.And_E);
            parsed = true;
        }

        return parsed;
    }

    private def shift(Ast ast) : var {
        var parsed = equality(ast);

        while(peek(1).getType() == TokenType.SHL
            || peek(1).getType() == TokenType.SHR) {
            advance();
            ast.add(current);

            equality(ast);
            ast = ast.encapsulate(AstType.Shift_E);
            parsed = true;
        }

        return parsed;
    }

    private def equality(Ast ast) : var {
        var parsed = comparison(ast);

        while(peek(1).getType() == TokenType.EQEQ
            || peek(1).getType() == TokenType.NOTEQ) {
            advance();
            ast.add(current);

            comparison(ast);
            ast = ast.encapsulate(AstType.Equal_E);
            parsed = true;
        }

        return parsed;
    }

    private def comparison(Ast ast) : var {
        var parsed = addition(ast);

        while(peek(1).getType() == TokenType.GREATERTHAN || peek(1).getType() == TokenType._GTE
            || peek(1).getType() == TokenType.LESSTHAN || peek(1).getType() == TokenType._LTE) {
            advance();
            ast.add(current);

            addition(ast);
            ast = ast.encapsulate(AstType.Less_E);
            parsed = true;
        }

        return parsed;
    }

    private def addition(Ast ast) : var {
        var parsed = multiplication(ast);

        while(peek(1).getType() == TokenType.MINUS || peek(1).getType() == TokenType.PLUS) {
            advance();
            ast.add(current);

            multiplication(ast);
            ast = ast.encapsulate(AstType.Add_E);
            parsed = true;
        }

        return parsed;
    }

    private def multiplication(Ast ast) : var {
        var parsed = unary(ast);

        while(peek(1).getType() == TokenType._DIV || peek(1).getType() == TokenType._MOD
            || peek(1).getType() == TokenType.MULT) {
            advance();
            ast.add(current);

            unary(ast);
            ast = ast.encapsulate(AstType.Mult_E);
            parsed = true;
        }

        return parsed;
    }

    private def unary(Ast ast) : var {
        if(peek(1).getType() == TokenType.MINUS) {
            advance();
            ast.add(current);

            var parsed = unary(ast);
            ast = ast.encapsulate(AstType.Add_E);
            return parsed;
        } else if(peek(1).getType() == TokenType.NOT) {
            advance();
            ast.add(current);

            var parsed = unary(ast);
            ast = ast.encapsulate(AstType.Not_E);
            return parsed;
        }

        retain(ast);
        errors.enableProtectedMode();
        if(!parsePrimaryExpression(ast))
        {
            errors.pass();
            rollbackLast(ast);
            return false;
        } else
        {
            dump();
            errors.fail();
            return true;
        }
    }

    private def parsePrimaryExpression(Ast ast) : var {
        ast = getAst(ast, AstType.Primary_Expression);

        errors.enableProtectedMode();
        retain(ast);
        if(parseLiteral(ast))
        {
            dump();
            errors.fail();
            ast.encapsulate(AstType.Literal_E);
            return true;
        }
        rollback(ast);
        errors.pass();

        errors.enableProtectedMode();
        if(peek(1).getType() == TokenType.DOT) {
            advance();
            ast.add(current);
        }

        retain(ast);
        if(parseUtype(ast))
        {
            if(peek(1).getType() == TokenType.DOT)
            {
                expect(TokenType.DOT, ast.getChild(0), "`.`");
                advance();

                expectToken(ast.getChild(0), "class", "`class` after primary expression");

                dump();
                errors.fail();
                ast.encapsulate(AstType.Utype_Class_E);
                return true;
            } else
                rollback(ast);
        } else
            rollback(ast);
        errors.pass();

        if(peek(1).getToken() == "self")
        {
            advance();
            expectToken(ast, "self");

            if(peek(1).getType() == TokenType.PTR) {
                expect(TokenType.PTR, ast, "`->` after self");
                parseDotNotationCallExpression(ast);
            }

            ast.encapsulate(AstType.Self_E);
            return true;
        }

        if(peek(1).getToken() == "base")
        {
            advance();
            expectToken(ast, "base");
            expect(TokenType.PTR, ast, "`->` after base");
            parseDotNotationCallExpression(ast);

            ast.encapsulate(AstType.Base_E);
            return true;
        }

        retain(ast);
        errors.enableProtectedMode();
        if(parseDotNotationCallExpression(ast)) {
            dump();
            errors.fail();
            ast.encapsulate(AstType.Dot_Not_E);
            if(!(peek(1).getType() == TokenType.LEFT_BRACE ||
                peek(1).getType() == TokenType._INC
                || peek(1).getType() == TokenType._DEC))
                return true;
        } else {
            errors.pass();
            rollback(ast);
        }

        if(peek(1).getToken() == "new")
        {
            advance();
            expectToken(ast, "new");
            parseUtypeNaked(ast);
            var newClass = false;

            if(peek(1).getType() == TokenType.LEFT_BRACE && parseArrayExpression(ast)){}
            else if(peek(1).getType() == TokenType.LEFT_BRACE) {
                expect(TokenType.LEFT_BRACE, ast, "`[`");
                expect(TokenType.RIGHT_BRACE, ast, "`]`");
                parseVectorArray(ast);
            }
            else if(peek(1).getType() == TokenType.LEFT_PAREN) {
                parseValueList(ast);
                newClass = true;
            }

            ast.encapsulate(AstType.New_E);
            if(peek(1).getType() != TokenType.LEFT_BRACE) {
                if(newClass && peek(1).getType() == TokenType.DOT)
                    parseDotNotationCallExpression(ast);
                return true;
            }
        }

        if(peek(1).getToken() == "sizeof")
        {
            advance();
            expectToken(ast, "sizeof");

            expect(TokenType.LEFT_PAREN, ast, "`(`");
            parseExpression(ast);
            expect(TokenType.RIGHT_PAREN, ast, "`)`");

            ast.encapsulate(AstType.Sizeof_E);
            return true;
        }

        if(peek(1).getType() == TokenType.LEFT_PAREN)
        {
            retain(ast);
            errors.enableProtectedMode();

            advance();
            ast.add(current);

            if(!parseUtype(ast))
            {
                errors.pass();
                rollback(ast);
            } else {
                if(peek(1).getType() == TokenType.RIGHT_PAREN)
                {
                    expect(TokenType.RIGHT_PAREN, ast, "`)`");
                    if(!parseExpression(ast))
                    {
                        errors.pass();
                        rollback(ast);
                    } else
                    {
                        dump();
                        errors.fail();
                        ast.encapsulate(AstType.Cast_E);
                        return true;
                    }
                }else {
                    errors.pass();
                    rollbackLast(ast);
                }
            }

        }

        if(peek(1).getType() == TokenType.LEFT_PAREN)
        {
            advance();
            ast.add(current);

            parseExpression(ast);

            expect(TokenType.RIGHT_PAREN, ast, "`)`");

            if(!isExprSymbol(peek(1).getToken())) {
                retain(ast);
                errors.enableProtectedMode();
                if(parseDotNotationCallExpression(ast)) {
                    dump();
                    errors.fail();
                } else {
                    errors.pass();
                    rollbackLast(ast);
                }

                ast.encapsulate(AstType.Paren_E);
                return true;
            } else
                ast.encapsulate(AstType.Paren_E);

            if(peek(1).getType() != TokenType.LEFT_BRACE)
                return true;
        }

        if(peek(1).getToken() == "null")
        {
            advance();
            expectToken(ast, "null");
            ast.encapsulate(AstType.Null_E);
            return true;
        }

        if(peek(1).getType() == TokenType.LEFT_BRACE)
        {
            expect(TokenType.LEFT_BRACE, ast, "`[`");
            parseExpression(ast);
            expect(TokenType.RIGHT_BRACE, ast, "`]`");



            if(!isOverrideOperator(peek(1).getToken())){
                errors.enableProtectedMode();
                retain(ast);
                if(!parseDotNotationCallExpression(ast)) {
                    rollbackLast(ast);
                    errors.pass();
                }
                else {
                    errors.fail();
                    dump();
                }

                ast.encapsulate(AstType.Arry_E);
                return true;
            }
            ast.encapsulate(AstType.Arry_E);

            if(!(peek(1).getType() == TokenType._INC ||
                peek(1).getType() == TokenType._DEC))
                return true;
        }

        /* ++ or -- after the expression */
        if(peek(1).getType() == TokenType._INC ||
            peek(1).getType() == TokenType._DEC)
        {
            advance();
            ast.add(current);
            ast.encapsulate(AstType.Post_Inc_E);
            return true;
        }

        return false;
    }

    private def parseArrayExpression(Ast ast) : var {
        ast = getAst(ast, AstType.Array_Expression);

        retain(ast);
        errors.enableProtectedMode();
        expect(TokenType.LEFT_BRACE, ast, "`[`");

        if(peek(1).getType() != TokenType.RIGHT_BRACE) {
            if(!parseExpression(ast))
            {
                errors.pass();
                rollback(ast);
                return false;
            } else
            {
                dump();
                errors.fail();
            }
        } else {
            if (peek(2).getType() == TokenType.LEFT_CURLY) {
                pushBack();
                return false;
            } else {
                dump();
                errors.fail();

                errors.createNewError(CompilerError.GENERIC, ast, "expected expression after '['");
                return false;
            }
        }

        expect(TokenType.RIGHT_BRACE, ast, "`]`");
        return true;
    }

    private def parseDotNotationCallExpression(Ast ast) : var
    {
        ast = getAst(ast, AstType.Dotnotation_Call_Expr);

        if(peek(1).getType() == TokenType.DOT)
        {
            advance();
            ast.add(current);
        }

        if(parseUtypeNaked(ast)) {
            if(peek(1).getType() == TokenType.LEFT_PAREN) {
                parseValueList(ast);

                ast.encapsulate(AstType.Dot_Fn_E);
                /* func()++ or func()--
                 * This expression rule dosen't process correctly by itsself
                 * so we hav to do it ourselves
                 */
                if(peek(1).getType() == TokenType._INC || peek(1).getType() == TokenType._DEC)
                {
                    advance();
                    ast.add(current);
                }
                else if(peek(1).getType() == TokenType.LEFT_BRACE) {
                    advance();
                    ast.add(current);

                    parseExpression(ast);
                    expect(TokenType.RIGHT_BRACE, ast, "`]`");

                    errors.enableProtectedMode();
                    retain(ast);
                    if(!parseDotNotationCallExpression(ast))
                    {
                        errors.pass();
                        rollbackLast(ast);
                    } else {
                        dump();
                        errors.fail();
                    }
                }
                else {
                    errors.enableProtectedMode();
                    retain(ast);
                    if(!parseDotNotationCallExpression(ast))
                    {
                        errors.pass();
                        rollbackLast(ast);
                    } else {
                        dump();
                        errors.fail();
                    }
                }
            }
        } else {
            pushBack();
            return false;
        }

        return true;
    }

    private def parseValueList(Ast ast) {
        ast = getAst(ast, AstType.Value_List);

        expect(TokenType.LEFT_PAREN, ast, "`(`");

        if(peek(1).getType() != TokenType.RIGHT_PAREN)
        {
            parseValue(ast);

            _pValue:
            if(peek(1).getType() == TokenType.COMMA)
            {
                expect(TokenType.COMMA, ast, "`,`");
                if(!parseValue(ast)){
                    errors.createNewError(CompilerError.GENERIC, ast.last(), "expected value");
                }
                goto _pValue;
            }
        }

        expect(TokenType.RIGHT_PAREN, ast, "`)`");
    }

    private def parseUtypeNaked(Ast ast) : var {
        ast = getAst(ast, AstType.Utype);

        if(parseTypeIdentifier(ast)) {
            return true;
        }
        else
            errors.createNewError(CompilerError.GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseLiteral(Ast ast) : var {
        ast = getAst(ast, AstType.Literal);

        TokenEntity token = peek(1);
        if(token.getId() == TokenId.CHAR_LITERAL || token.getId() == TokenId.INTEGER_LITERAL
            || token.getId() == TokenId.STRING_LITERAL || token.getId() == TokenId.HEX_LITERAL
            || token.getToken() == "true" || token.getToken() == "false")
        {
            advance();
            ast.add(current);
            return true;
        } else {
            errors.createNewError(CompilerError.GENERIC, current, "expected literal of type (string, char, hex, or bool)");
            return false;
        }
    }

    private def rollbackLast(Ast ast) {
        if(states.size() > 0) {
            cursor = states.keyAt(states.size() -1);
            advance();

            if(ast.childrenSize() == 1) {
                ast.clear();
            } else
                ast.popChild();

            states.drop();
        }
    }

    private def rollback(Ast ast) {
        if(states.size() > 0) {
            cursor = states.keyAt(states.size() -1);
            Ast tmp = states.valueAt(states.size() -1);
            ast.copy(tmp);
            advance();

            states.drop();
        }
    }

    private def dump() {
        if(states.size() > 0)
            states.removeAt(states.size()-1);
    }

    private def retain(Ast ast) {
        Ast copy = new Ast();
        copy.copy(ast);
        states.put(cursor, copy);
    }

    private def parseVectorArray(Ast ast) {
        ast = getAst(ast, AstType.Vector_Array);
        expect(TokenType.LEFT_CURLY, ast, "`{`");

        if(peek(1).getType() != TokenType.RIGHT_CURLY) {
            parseExpression(ast);
            _pExpr:
            if(peek(1).getType() == TokenType.COMMA)
            {
                expect(TokenType.COMMA, ast, "`,`");
                parseExpression(ast);
                goto _pExpr;
            }
        }

        expect(TokenType.RIGHT_CURLY, ast, "`}`");
    }

    private def parseIdentifierList(Ast ast) {
        ast = getAst(ast, AstType.Identifier_List);

        expectIdentifier(ast);
        pRefPtr:
        if(peek(1).getType() == TokenType.COMMA) {
            expect(TokenType.COMMA, ast, "`,`");
            expectIdentifier(ast);
            goto pRefPtr;
        }
    }

    private def parseRefrenceIdentifierList(Ast ast) {
        ast = getAst(ast, AstType.Identifier_List);

        parseReferencePointer(ast);
        pRefPtr:
        if(peek(1).getType() == TokenType.COMMA) {
            expect(TokenType.COMMA, ast, "`,`");
            parseReferencePointer(ast);
            goto pRefPtr;
        }
    }

    private def parseModuleDecl(Ast ast) {
        ast = getAst(ast, AstType.Module_Decl);
        ast.add(current);

        bool generic = false;
        parseModuleName(ast, generic);

        if(generic.getValue())
            errors.createNewError(CompilerError.GENERIC, current, "module-name does not allow for generic typing ");

        expect(TokenType.SEMICOLON, ast, "`;`");
    }

    private def parseModuleName(Ast ast, bool generic) {
        parseModuleName(ast, generic, false);
    }


    private def parseModuleName(Ast ast, bool generic, var local) {
        if(!local)
            ast = getAst(ast, AstType.ModuleName);

        if(peek(1).getToken() == "operator") {
            if(isOverrideOperator(peek(2).getToken())) {
                advance(2);
                ast.add(current);
                return;
            }
        }else {
            expectIdentifier(ast);
            generic = parseTemplateDecl(ast);
        }

         advance();
         while(current.getType() == TokenType.DOT) {
             if(peek(1).getToken() == CLASS)
                 break;

             ast.add(current);

             if(peek(1).getToken() == "operator") {
                 if(isOverrideOperator(peek(2).getToken())) {
                     advance(2);
                     ast.add(current);
                     advance();
                     break;
                 }
             } else {
                 if(expectIdentifier(ast)){
                     if(parseTemplateDecl(ast))
                         generic = true;
                 }
             }
             advance();
         }

         pushBack();
    }

    private def parseTemplateDecl(Ast ast) : var {
        if(peek(1).getType() == TokenType.LESSTHAN) {
            advance();
            Ast tmp = new Ast();
            tmp.copy(ast);

            if(peek(1).getType() == TokenType.GREATERTHAN) {
                errors.createNewError(CompilerError.GENERIC, current, "expected identifier before `>`");
                advance();
                return true;
            }

            if(parseUtype(ast) && (peek(1).getType() == TokenType.GREATERTHAN || peek(1).getType() == TokenType.COMMA))
            {
                ast.copy(tmp);
                errors.pass();
                parseUtypeList(ast);
                if(peek(1).getType() == TokenType.GREATERTHAN) {
                    expect(TokenType.GREATERTHAN, ast, "`>`");
                    ast.popToken();
                } else
                    expect(TokenType.GREATERTHAN, ast, "`>`");

                return true;
            } else
                ast.copy(tmp);

            errors.pass();
            pushBack();
        }

        getAst(ast, AstType.None);
        return false;
    }

    private def parseUtypeListOpt(Ast ast) {
        ast = getAst(ast, AstType.Utype_Arg_List_Opt);
        expect(TokenType.LEFT_PAREN, ast, "`(`");

        if(peek(1).getType() != TokenType.RIGHT_PAREN)
        {
            if(isDecl(peek(1), PROTOTYPE))
                parseProtoTypeDecl(ast, false);
            else
                parseUtypeArgOpt(ast);
            _puTypeArgOpt:
            if(peek(1).getType() == TokenType.COMMA)
            {
                expect(TokenType.COMMA, ast, "`,`");

                if(isDecl(peek(1), PROTOTYPE))
                    parseProtoTypeDecl(ast, false);
                else
                    parseUtypeArgOpt(ast);
                goto _puTypeArgOpt;
            }
        }

        expect(TokenType.RIGHT_PAREN, ast, "`)`");
    }


    private def parseUtypeArgList(Ast ast) {
        ast = getAst(ast, AstType.Utype_Arg_List);
        expect(TokenType.LEFT_PAREN, ast, "`(`");

        if(peek(1).getType() != TokenType.RIGHT_PAREN)
        {
            if(isDecl(peek(1), PROTOTYPE))
                parseProtoTypeDecl(ast, false);
            else
                parseUtypeArg(ast);
            _puTypeArg:
            if(peek(1).getType() == TokenType.COMMA)
            {
                expect(TokenType.COMMA, ast, "`,`");

                if(isDecl(peek(1), PROTOTYPE))
                    parseProtoTypeDecl(ast, false);
                else
                    parseUtypeArg(ast);
                goto _puTypeArg;
            }
        }

        expect(TokenType.RIGHT_PAREN, ast, "`)`");
    }

    private def parseUtypeArg(Ast ast) : var {
        ast = getAst(ast, AstType.Utype_Arg);

        if(parseUtype(ast))
        {
            expectIdentifier(ast);
            return true;
        }else
            errors.createNewError(CompilerError.GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseUtypeArgOpt(Ast ast) : var {
        ast = getAst(ast, AstType.Utype_Arg_Opt);

        if(parseUtype(ast))
        {
            errors.enableProtectedMode();
            if(!expectIdentifier(ast)) {
                errors.pass();
                pushBack();
            }
            else
                errors.fail();
            return true;
        }else
            errors.createNewError(CompilerError.GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseUtypeList(Ast ast) {
        ast = getAst(ast, AstType.Utype_List);

        parseUtype(ast);
        pRefPtr:
        if(peek(1).getType() == TokenType.COMMA)
        {
            expect(TokenType.COMMA, ast, "`,`");
            parseUtype(ast);
            goto pRefPtr;
        }
    }

    private def parseUtype(Ast ast) : var {
        ast = getAst(ast, AstType.Utype);

        if(parseTypeIdentifier(ast))
        {
            if(peek(1).getType() == TokenType.LEFT_BRACE)
            {
                advance();
                ast.add(current);

                expect(TokenType.RIGHT_BRACE, ast, "`]`");
            }

            return true;
        } else
            errors.createNewError(CompilerError.GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseTypeIdentifier(Ast ast) : var {
        ast = getAst(ast, AstType.Type_Identifier);
        advance();

        if(!isNativeType(current.getToken()))
            pushBack();
        else {
            ast.add(current);
            return true;
        }

        errors.enableProtectedMode();
        if(!parseReferencePointer(ast)) {
            errors.pass();
        } else {
            errors.fail();
            return true;
        }

        return false;
    }

    private def parseReferencePointer(Ast ast) : var {
        ast = getAst(ast, AstType.Reference_Pointer);

        advance();
        if(!(current.getId() == TokenId.IDENTIFIER && !isKeyword(current.getToken()))) {
            if(current.getToken() != "operator")
                return false;
            else
                pushBack();
        } else
            pushBack();

        bool generic = false;
        parseModuleName(ast, generic, true);

        advance();
        if(current.getType() == TokenType.HASH) {
            if(generic)
                errors.createNewError(CompilerError.GENERIC, current, "module-name does not allow for generic typing ");
            ast.add(current);

            if(expectIdentifier(ast)) {
                parseTemplateDecl(ast);
                advance();
            }

            while(current.getType() == TokenType.DOT ) {
                if(peek(1).getToken() == CLASS)
                    break;

                ast.add(current);

                if(peek(1).getToken() == "operator") {
                    if(isOverrideOperator(peek(2).getToken())) {
                        advance(2);
                        ast.add(current);
                        break;
                    }
                } else {
                    if(!expectIdentifier(ast)) break;

                    parseTemplateDecl(ast);
                }
                advance();
            }

            pushBack();
        } else
            pushBack();

             return true;
    }

    private def isNativeType(string type) : var {
        return type == "var" || type == "object"
               || type == "_int8" || type == "_int16"
               || type == "_int32" || type == "_int64"
               || type == "_uint8" || type == "_uint16"
               || type == "_uint32" || type == "_uint64";
    }

    public def expect(TokenType type, Ast ast, var[] msg) {
        advance();

        if(current.getType() == type) {
            ast.add(current);
        } else {
            errors.createNewError(CompilerError.GENERIC, current, "expected " + msg);
        }
    }

    public def expect(TokenType type, var[] msg) : var {
        advance();

        if(current.getType() == type) {
            return true;
        } else {
            errors.createNewError(CompilerError.GENERIC, current, "expected " + msg);
        }

        return false;
    }

    public def expectToken(Ast ast, var[] token) {

        if(current.getToken() != token) {
            errors.createNewError(CompilerError.GENERIC, current, "expected `" + token + "`");
        } else {
            ast.add(current);
        }
    }

    public def expectToken(Ast ast, var[] token, var[] msg) {

        if(current.getToken() != token) {
            errors.createNewError(CompilerError.GENERIC, current, "" + msg);
        } else {
            ast.add(current);
        }
    }

    private def pushBack() {
        if(cursor > 0) {
            current = tokenizer.get(--cursor);
        }
    }

    private def isAssignOperator(string token) : var {
        return token == "+=" || token == "-="||
               token == "*=" || token == "/="||
               token == "&=" || token == "|="||
               token == "^=" || token == "%="||
               token == "=";
    }

    private def isOverrideOperator(string token) : var  {
        return isAssignOperator(token) ||
               token == "++" ||token == "--" ||
               token == "*" || token == "/"  ||
               token == "%" || token == "-"  ||
               token == "+" || token == "==" ||
               token == "&&" || token == "||" ||
               token == ">>" || token == "<<" ||
               token == "<"  || token == ">"  ||
               token == "<=" || token == ">=" ||
               token == "!=";
    }

    def isExprSymbol(string token) : var {
        return token == "[" || token == "++" ||
               token == "--" || token == "*" ||
               token == "/" || token == "%" ||
               token == "-" || token == "+"||
               token == ">>" || token == "<<"||
               token == "<" || token == ">"||
               token == "<=" || token == ">="||
               token == "==" || token == "!="||
               token == "&" || token == "|"||
               token == "&&" || token == "||"||
               token == "^" || token == "?" ||
               isAssignOperator(token);
    }

    private def expectIdentifier(Ast ast) : var {
        advance();

        if(current.getId() == TokenId.IDENTIFIER && !isKeyword(current.getToken()))
        {
            ast.add(current);
            return true;
        } else {
            errors.createNewError(CompilerError.GENERIC, current, "expected identifier");
        }

        return false;
    }

    private def isKeyword(string key) : var {
        return key == "mod" || key == "true"
               || key == "false" || key == "class"
               || key == "static" || key == "protected"
               || key == "private" || key == "def"
               || key == "import" || key == "return"
               || key == "self" || key == "const"
               || key == "public" || key == "new"
               || key == "null" || key == "operator"
               || key == "base" || key == "if" || key == "while" || key == "do"
               || key == "try" || key == "catch"
               || key == "finally" || key == "throw" || key == "continue"
               || key == "goto" || key == "break" || key == "else"
               || key == "object" || key == "asm" || key == "for" || key == "foreach"
               || key == "var" || key == "sizeof"|| key == "_int8" || key == "_int16"
               || key == "_int32" || key == "_int64" || key == "_uint8"
               || key == "_uint16"|| key == "_uint32" || key == "_uint64"
               || key == "delegate" || key == "interface" || key == "lock" || key == "enum"
               || key == "switch" || key == "default";
    }

    private def peek(var forward) : TokenEntity {
        if((cursor+forward) >= tokenizer.size())
            return tokenizer.last();
        else
            return tokenizer.get(cursor+forward);
    }

    private def getAst(Ast ast, AstType type) : Ast {
        if(ast == null)
        {
            tree.add(new Ast(null, type, current.getLine(), current.getCol()));
            return tree.last();
        } else {
            ast.add(new Ast(ast, type, current.getLine(), current.getCol()));
            return ast.last();
        }
    }

    private def isDecl(TokenEntity token, var[] value) : var {
        return token.getId() == TokenId.IDENTIFIER && token.getToken() == value;
    }

    private def quit() : var {
        if(panic) return true;
        else if(errors.getRawErrorCount() > Options.maxErrors) {
            panic = true;
            return true;
        }

        return false;
    }

    private def parseAccessTypes() {
        accessTypes.clear();

        while(isAccessType(current))
        {
            accessTypes.add(current);
            advance();
        }
    }

    private def advance() {
        if((cursor+1) < tokenizer.size())
            current = tokenizer.get(++cursor);
        else current = tokenizer.last();
    }

    private def advance(var forward) {
        if((cursor+forward) < tokenizer.size()) {
            cursor += forward;
            current = tokenizer.get(cursor);
        } else current = tokenizer.last();
    }

    private def isAccessType(TokenEntity token) : var {
        return
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "protected" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "private" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "static" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "const" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "public";
    }

    private def isEnd() : var {
        return current.getType() == TokenType._EOF;
    }

    private static const var[] INTERFACE = "interface";
    private static const var[] MOD = "mod";
    private static const var[] CLASS = "class";
    private static const var[] IMPORT = "import";
    private static const var[] VAR = "var";
    private static const var[] OBJECT = "object";
    private static const var[] PROTOTYPE = "fn";
    private static const var[] METHOD = "def";

    private string sourceFile = "";
    private var panic;
    private var cursor;
    private ArrayList<Ast> tree;
    private Dictionary<var, Ast> states;
    private ArrayList<string> lines;
    private TokenEntity current;
    private Tokenizer tokenizer;
    private string data = "";
    private ArrayList<TokenEntity> accessTypes;
    private ErrorManager errors;
}