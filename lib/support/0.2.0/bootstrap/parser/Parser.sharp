mod app;

import std;

/**                          
* Created by bknun on 7/5/2018            
* Description:                             
*/
class Parser {
    public Parser(Tokenizer tokenizer)
    {
        self->tokenizer=tokenizer;

        if(tokenizer != null && tokenizer.getErrors() != null
            && !tokenizer.getErrors().hasErrors())
        {
            data = tokenizer.getData();
            accessTypes = new ArrayList<TokenEntity>();
            tree = new ArrayList<Ast>();
            states = new Dictionary<var, Ast>();
            lines = tokenizer.getLines();

            parse();
        }
    }

    private def parse() {
        sourceFile = tokenizer.getFile();
        errors = new ErrorManager(lines, sourceFile, true, Options.aggressiveErrors);
        current = tokenizer.get(cursor);


        while (!isEnd())
        {
            if(panic)
                break;

            if(isAccessType(current))
                parseAccessTypes();

            if(quit()) break;

            if(isEnd()) {
                accessTypes.clear();
                return;
            } else if(isDecl(current, MOD)) {
                if(accessTypes.size() > 0)
                    errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");
                parseModuleDecl(null);
            } else if(isDecl(current, CLASS)) {
                parseClassDecl(null);
            }

            advance();
        }
    }

    private def parseClassDecl(Ast ast) {
        ast = getAst(ast, AstType.Class_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }

        ast.add(current);
        expectIdentifier(ast);

        if(peek(1).getToken() == "<") {
            ast.setType(AstType.Generic_Class_Decl);

            expect(TokenType.LESSTHAN, "`<`");
            parseIdentifierList(ast);
            expect(TokenType.GREATERTHAN, "`>`");
        }

        if(peek(1).getToken() == "base") {
            advance();
            expectToken(ast, "base");
            parseReferencePointer(ast);
        }

        if(peek(1).getToken() == ":") {
            expect(TokenType.COLON, "`:`");
            parseRefrenceIdentifierList(ast);
        }

        parseClassBlock(ast);
    }

    private def parseClassBlock(Ast ast) {
        expect(TokenType.LEFT_CURLY, "`{` after class decliration");
        ast = getAst(ast, AstType.Class_Decl);

        var brackets = 1;
        while(!isEnd() && brackets > 0) {
            if(quit()) break;

            advance();
            if(isAccessType(current))
                parseAccessTypes();

            if(isDecl(current, MOD)) {
                if(accessTypes.size() > 0)
                     errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");

                errors.createNewError(CompilerError.GENERIC, current, "unexpected module declaration");
                parseModuleDecl(ast);
            } else if(isDecl(current, CLASS)) {
                parseClassDecl(ast);
            } else if(isDecl(current, INTERFACE)) {
                parseInterfaceDecl(ast);
            }
        }
    }

    private def parseInterfaceDecl(Ast ast) {
        ast = getAst(ast, AstType.Interface_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }

        ast.add(current);
        expectIdentifier(ast);

        if(peek(1).getToken() == "<") {
            ast.setType(AstType.Generic_Interface_Decl);

            expect(TokenType.LESSTHAN, "`<`");
            parseIdentifierList(ast);
            expect(TokenType.GREATERTHAN, "`>`");
        }

        if(peek(1).getToken() == "base")
        {
            advance();
            expectToken(ast, "base");
            parseReferencePointer(ast);
        }

        parseInterfaceBlock(ast);
    }

    private def parseInterfaceBlock(Ast ast) {
        expect(TokenType.LEFT_CURLY, "`{` after interface declaration");
        ast = getAst(ast, AstType.Block);

        var brackets = 1;
        while(!isEnd() && brackets > 0) {
            if(quit()) break;

            advance();

            if(isAccessType(current))
                parseAccessTypes();

            if(isDecl(current, MOD)) {
                if(accessTypes.size() > 0)
                     errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");

                errors.createNewError(CompilerError.GENERIC, current, "unexpected module declaration");
                parseModuleDecl(ast);
            } else if(isDecl(current, INTERFACE)) {
                parseInterfaceDecl(ast);
            } else if(isDecl(current, IMPORT)) {
                 if(accessTypes.size() > 0)
                      errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");

                 errors.createNewError(CompilerError.GENERIC, current, "unexpected import declaration");
                 parseImportDecl(ast);
            } else if(isDecl(current, VAR) || isDecl(current, OBJECT)) {
                 if(accessTypes.size() > 0)
                      errors.createNewError(CompilerError.ILLEGAL_ACCESS_DECLARATION, current, "");

                 errors.createNewError(CompilerError.GENERIC, current, "unexpected variable declaration");
                 parseVariableDecl(ast);
            }
        }
    }

    private def parseImportDecl(Ast ast) {
        ast = getAst(ast, AstType.Import_Decl);
        ast.add(current);

        bool generic = false;
        parseModuleName(ast, generic);

        if(generic.getValue())
            errors.createNewError(CompilerError.GENERIC, current, "module-name does not allow for generic typing ");

        expect(TokenType.SEMICOLON, ast, "`;`");
    }

    var partialDecl = 0;
    private def parseVariableDecl(Ast ast) {
        ast = getAst(ast, AstType.Var_Decl);

        if(partialDecl == 0) {
            TokenEntity[] arry = accessTypes.toArray();
            foreach(TokenEntity token : arry) {
                ast.add(token);
            }

            pushBack();
            if(!parseUtype(ast))
                errors.createNewError(CompilerError.GENERIC, current, "expected native type or reference pointer");

        } else
            partialDecl--;

        expectIdentifier(ast);
        parseValueAssignment(ast);

        if(peek(1).getType() == TokenType.COMMA) {
            partialDecl++;
            expect(TokenType.COMMA, "`,`");

            parseVariableDecl(partialDecl <= 1 ? ast : ast.getParent());
        } else if(partialDecl == 0)
            expect(TokenType.SEMICOLON, "`;`");
    }

    private def parseValueAssignment(Ast ast) {
        advance();
        if(isAssignOperator(current.getToken())) {
            ast.add(current);
            parseValue(ast);
        }
        else
            pushBack();
    }

    private def parseValue(Ast ast) : var {
        ast = getAst(ast, AstType.Value);
        return parseExpression(ast);
    }

    private def parseExpression(Ast ast) : var {
        ast = getAst(ast, AstType.Expression);
        if(quit()) return false;

        if(peek(1).getType() == TokenType._INC
            || peek(1).getType() == TokenType._DEC) {
            advance();
            ast.add(current);
            parseExpression(ast);
            ast.encapsulate(AstType.Pre_Inc_E);
            return true;
        }

        if(peek(1).getType() == TokenType.LEFT_CURLY) {
            parseVectorArray(ast);
            ast.encapsulate(AstType.Vect_E);
            return true;
        }

        retain(ast);
        if(parsePrimaryExpression(ast)) {
            dump();
            return true;
        } else {
            rollbackLast(ast);
        }
    }

    private def parsePrimaryExpression(Ast ast) : var {
        ast = getAst(ast, AstType.Primary_Expression);

        errors.enableProtectedMode();
        retain(ast);
        if(parseLiteral(ast))
        {
            dump();
            errors.fail();
            ast.encapsulate(AstType.Literal_E);
            return true;
        }
        rollback(ast);
        errors.pass();

        errors.enableProtectedMode();
        if(peek(1).getType() == TokenType.DOT) {
            advance();
            ast.add(current);
        }

        retain(ast);
        if(parseUtype(ast))
        {
            if(peek(1).getType() == TokenType.DOT)
            {
                expect(TokenType.DOT, ast.getChild(0), "`.`");
                advance();

                expectToken(ast.getChild(0), "class", "`class` after primary expression");

                dump();
                errors.fail();
                ast.encapsulate(AstType.Utype_Class_E);
                return true;
            } else
                rollback(ast);
        } else
            rollback(ast);
        errors.pass();

        if(peek(1).getToken() == "self")
        {
            advance();
            expectToken(ast, "self");

            if(peek(1).getType() == TokenType.PTR) {
                expect(TokenType.PTR, ast, "`->` after self");
                parseDotNotationCallExpression(ast);
            }

            ast.encapsulate(AstType.Self_E);
            return true;
        }

        if(peek(1).getToken() == "base")
        {
            advance();
            expectToken(ast, "base");
            expect(TokenType.PTR, ast, "`->` after base");
            parseDotNotationCallExpression(ast);

            ast.encapsulate(AstType.Base_E);
            return true;
        }

        retain(ast);
        errors.enableProtectedMode();
        if(parseDotNotationCallExpression(ast)) {
            dump();
            errors.fail();
            ast.encapsulate(AstType.Dot_Not_E);
            if(!(peek(1).getType() == TokenType.LEFT_BRACE ||
                peek(1).getType() == TokenType._INC
                || peek(1).getType() == TokenType._DEC))
                return true;
        } else {
            errors.pass();
            rollback(ast);
        }

        if(peek(1).getToken() == "new")
        {
            advance();
            expectToken(ast, "new");
            parseUtypeNaked(ast);
            var newClass = false;

            if(peek(1).getType() == TokenType.LEFT_BRACE && parseArrayExpression(ast)){}
            else if(peek(1).getType() == TokenType.LEFT_BRACE) {
                expect(TokenType.LEFT_BRACE, ast, "`[`");
                expect(TokenType.RIGHT_BRACE, ast, "`]`");
                parseVectorArray(ast);
            }
            else if(peek(1).getType() == TokenType.LEFT_PAREN) {
                parseValueList(ast);
                newClass = true;
            }

            ast.encapsulate(AstType.New_E);
            if(peek(1).getType() != TokenType.LEFT_BRACE) {
                if(newClass && peek(1).getType() == TokenType.DOT)
                    parseDotNotationCallExpression(ast);
                return true;
            }
        }

        if(peek(1).getToken() == "sizeof")
        {
            advance();
            expectToken(ast, "sizeof");

            expect(TokenType.LEFT_PAREN, ast, "`(`");
            parseExpression(ast);
            expect(TokenType.RIGHT_PAREN, ast, "`)`");

            ast.encapsulate(AstType.Sizeof_E);
            return true;
        }

        if(peek(1).getType() == TokenType.LEFT_PAREN)
        {
            retain(ast);
            errors.enableProtectedMode();

            advance();
            ast.add(current);

            if(!parseUtype(ast))
            {
                errors.pass();
                rollback(ast);
            } else {
                if(peek(1).getType() == TokenType.RIGHT_PAREN)
                {
                    expect(TokenType.RIGHT_PAREN, ast, "`)`");
                    if(!parseExpression(ast))
                    {
                        errors.pass();
                        rollback(ast);
                    } else
                    {
                        dump();
                        errors.fail();
                        ast.encapsulate(AstType.Cast_E);
                        return true;
                    }
                }else {
                    errors.pass();
                    rollbackLast(ast);
                }
            }

        }

        if(peek(1).getType() == TokenType.LEFT_PAREN)
        {
            advance();
            ast.add(current);

            parseExpression(ast);

            expect(TokenType.RIGHT_PAREN, ast, "`)`");

            if(!isExprSymbol(peek(1).getToken())) {
                retain(ast);
                errors.enableProtectedMode();
                if(parseDotNotationCallExpression(ast)) {
                    dump();
                    errors.fail();
                } else {
                    errors.pass();
                    rollbackLast(ast);
                }

                ast.encapsulate(AstType.Paren_E);
                return true;
            } else
                ast.encapsulate(AstType.Paren_E);

            if(peek(1).getType() != TokenType.LEFT_BRACE)
                return true;
        }

        if(peek(1).getToken() == "null")
        {
            advance();
            expectToken(ast, "null");
            ast.encapsulate(AstType.Null_E);
            return true;
        }
    }

    private def parseArrayExpression(Ast ast) : var {
        ast = getAst(ast, AstType.Array_Expression);

        retain(ast);
        errors.enableProtectedMode();
        expect(TokenType.LEFT_BRACE, ast, "`[`");

        if(peek(1).getType() != TokenType.RIGHT_BRACE) {
            if(!parseExpression(ast))
            {
                errors.pass();
                rollback(ast);
                return false;
            } else
            {
                dump();
                errors.fail();
            }
        } else {
            if (peek(2).getType() == TokenType.LEFT_CURLY) {
                pushBack();
                return false;
            } else {
                dump();
                errors.fail();

                errors.createNewError(CompilerError.GENERIC, ast, "expected expression after '['");
                return false;
            }
        }

        expect(TokenType.RIGHT_BRACE, ast, "`]`");
        return true;
    }

    private def parseDotNotationCallExpression(Ast ast) : var
    {
        ast = getAst(ast, AstType.Dotnotation_Call_Expr);

        if(peek(1).getType() == TokenType.DOT)
        {
            advance();
            ast.add(current);
        }

        if(parseUtypeNaked(ast)) {
            if(peek(1).getType() == TokenType.LEFT_PAREN) {
                parseValueList(ast);

                ast.encapsulate(AstType.Dot_Fn_E);
                /* func()++ or func()--
                 * This expression rule dosen't process correctly by itsself
                 * so we hav to do it ourselves
                 */
                if(peek(1).getType() == TokenType._INC || peek(1).getType() == TokenType._DEC)
                {
                    advance();
                    ast.add(current);
                }
                else if(peek(1).getType() == TokenType.LEFT_BRACE) {
                    advance();
                    ast.add(current);

                    parseExpression(ast);
                    expect(TokenType.RIGHT_BRACE, ast, "`]`");

                    errors.enableProtectedMode();
                    retain(ast);
                    if(!parseDotNotationCallExpression(ast))
                    {
                        errors.pass();
                        rollbackLast(ast);
                    } else {
                        dump();
                        errors.fail();
                    }
                }
                else {
                    errors.enableProtectedMode();
                    retain(ast);
                    if(!parseDotNotationCallExpression(ast))
                    {
                        errors.pass();
                        rollbackLast(ast);
                    } else {
                        dump();
                        errors.fail();
                    }
                }
            }
        } else {
            pushBack();
            return false;
        }

        return true;
    }

    private def parseValueList(Ast ast) {
        ast = getAst(ast, AstType.Value_List);

        expect(TokenType.LEFT_PAREN, ast, "`(`");

        if(peek(1).getType() != TokenType.RIGHT_PAREN)
        {
            parseValue(ast);

            _pValue:
            if(peek(1).getType() == TokenType.COMMA)
            {
                expect(TokenType.COMMA, ast, "`,`");
                if(!parseValue(ast)){
                    errors.createNewError(CompilerError.GENERIC, ast.last(), "expected value");
                }
                goto _pValue;
            }
        }

        expect(TokenType.RIGHT_PAREN, ast, "`)`");
    }

    private def parseUtypeNaked(Ast ast) : var {
        ast = getAst(ast, AstType.Utype);

        if(parseTypeIdentifier(ast)) {
            return true;
        }
        else
            errors.createNewError(CompilerError.GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseLiteral(Ast ast) : var {
        ast = getAst(ast, AstType.Literal);

        TokenEntity token = peek(1);
        if(token.getId() == TokenId.CHAR_LITERAL || token.getId() == TokenId.INTEGER_LITERAL
            || token.getId() == TokenId.STRING_LITERAL || token.getId() == TokenId.HEX_LITERAL
            || token.getToken() == "true" || token.getToken() == "false")
        {
            advance();
            ast.add(current);
            return true;
        } else {
            errors.createNewError(CompilerError.GENERIC, current, "expected literal of type (string, char, hex, or bool)");
            return false;
        }
    }

    private def rollbackLast(Ast ast) {
        if(states.size() > 0) {
            cursor = states.keyAt(states.size() -1);
            advance();

            if(ast.childrenSize() == 1) {
                ast.clear();
            } else
                ast.popChild();

            states.drop();
        }
    }

    private def rollback(Ast ast) {
        if(states.size() > 0) {
            cursor = states.keyAt(states.size() -1);
            Ast tmp = states.valueAt(states.size() -1);
            ast.copy(tmp);
            advance();

            states.drop();
        }
    }

    private def dump() {
        if(states.size() > 0)
            states.removeAt(states.size()-1);
    }

    private def retain(Ast ast) {
        Ast copy = new Ast();
        copy.copy(ast);
        states.put(cursor, copy);
    }

    private def parseVectorArray(Ast ast) {
        ast = getAst(ast, AstType.Vector_Array);
        expect(TokenType.LEFT_CURLY, ast, "`{`");

        if(peek(1).getType() != TokenType.RIGHT_CURLY) {
            parseExpression(ast);
            _pExpr:
            if(peek(1).getType() == TokenType.COMMA)
            {
                expect(TokenType.COMMA, ast, "`,`");
                parseExpression(ast);
                goto _pExpr;
            }
        }

        expect(TokenType.RIGHT_CURLY, ast, "`}`");
    }

    private def parseIdentifierList(Ast ast) {
        ast = getAst(ast, AstType.Identifier_List);

        expectIdentifier(ast);
        pRefPtr:
        if(peek(1).getType() == TokenType.COMMA) {
            expect(TokenType.COMMA, ast, "`,`");
            expectIdentifier(ast);
            goto pRefPtr;
        }
    }

    private def parseRefrenceIdentifierList(Ast ast) {
        ast = getAst(ast, AstType.Identifier_List);

        parseReferencePointer(ast);
        pRefPtr:
        if(peek(1).getType() == TokenType.COMMA) {
            expect(TokenType.COMMA, ast, "`,`");
            parseReferencePointer(ast);
            goto pRefPtr;
        }
    }

    private def parseModuleDecl(Ast ast) {
        ast = getAst(ast, AstType.Module_Decl);
        ast.add(current);

        bool generic = false;
        parseModuleName(ast, generic);

        if(generic.getValue())
            errors.createNewError(CompilerError.GENERIC, current, "module-name does not allow for generic typing ");

        expect(TokenType.SEMICOLON, ast, "`;`");
    }

    private def parseModuleName(Ast ast, bool generic) {
        parseModuleName(ast, generic, false);
    }


    private def parseModuleName(Ast ast, bool generic, var local) {
        if(!local)
            ast = getAst(ast, AstType.ModuleName);

        if(peek(1).getToken() == "operator") {
            if(isOverrideOperator(peek(2).getToken())) {
                advance(2);
                ast.add(current);
                return;
            }
        }else {
            expectIdentifier(ast);
            generic = parseTemplateDecl(ast);
        }

         advance();
         while(current.getType() == TokenType.DOT) {
             if(peek(1).getToken() == CLASS)
                 break;

             ast.add(current);

             if(peek(1).getToken() == "operator") {
                 if(isOverrideOperator(peek(2).getToken())) {
                     advance(2);
                     ast.add(current);
                     advance();
                     break;
                 }
             } else {
                 if(expectIdentifier(ast)){
                     if(parseTemplateDecl(ast))
                         generic = true;
                 }
             }
             advance();
         }

         pushBack();
    }

    private def parseTemplateDecl(Ast ast) : var {
        if(peek(1).getType() == TokenType.LESSTHAN) {
            advance();
            Ast tmp = new Ast();
            tmp.copy(ast);

            if(peek(1).getType() == TokenType.GREATERTHAN) {
                errors.createNewError(CompilerError.GENERIC, current, "expected identifier before `>`");
                advance();
                return true;
            }

            if(parseUtype(ast) && (peek(1).getType() == TokenType.GREATERTHAN || peek(1).getType() == TokenType.COMMA))
            {
                ast.copy(tmp);
                errors.pass();
                parseUtypeList(ast);
                if(peek(1).getType() == TokenType.GREATERTHAN) {
                    expect(TokenType.GREATERTHAN, ast, "`>`");
                    ast.popToken();
                } else
                    expect(TokenType.GREATERTHAN, ast, "`>`");

                return true;
            } else
                ast.copy(tmp);

            errors.pass();
            pushBack();
        }

        getAst(ast, AstType.None);
        return false;
    }

    private def parseUtypeList(Ast ast) {
        ast = getAst(ast, AstType.Utype_List);

        parseUtype(ast);
        pRefPtr:
        if(peek(1).getType() == TokenType.COMMA)
        {
            expect(TokenType.COMMA, ast, "`,`");
            parseUtype(ast);
            goto pRefPtr;
        }
    }

    private def parseUtype(Ast ast) : var {
        ast = getAst(ast, AstType.Utype);

        if(parseTypeIdentifier(ast))
        {
            if(peek(1).getType() == TokenType.LEFT_BRACE)
            {
                advance();
                ast.add(current);

                expect(TokenType.RIGHT_BRACE, ast, "`]`");
            }

            return true;
        } else
            errors.createNewError(CompilerError.GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseTypeIdentifier(Ast ast) : var {
        ast = getAst(ast, AstType.Type_Identifier);
        advance();

        if(!isNativeType(current.getToken()))
            pushBack();
        else {
            ast.add(current);
            return true;
        }

        errors.enableProtectedMode();
        if(!parseReferencePointer(ast)) {
            errors.pass();
        } else {
            errors.fail();
            return true;
        }

        return false;
    }

    private def parseReferencePointer(Ast ast) : var {
        ast = getAst(ast, AstType.Reference_Pointer);

        advance();
        if(!(current.getId() == TokenId.IDENTIFIER && !isKeyword(current.getToken()))) {
            if(current.getToken() != "operator")
                return false;
            else
                pushBack();
        } else
            pushBack();

        bool generic = false;
        parseModuleName(ast, generic, true);

        advance();
        if(current.getType() == TokenType.HASH) {
            if(generic)
                errors.createNewError(CompilerError.GENERIC, current, "module-name does not allow for generic typing ");
            ast.add(current);

            if(expectIdentifier(ast)) {
                parseTemplateDecl(ast);
                advance();
            }

            while(current.getType() == TokenType.DOT ) {
                if(peek(1).getToken() == CLASS)
                    break;

                ast.add(current);

                if(peek(1).getToken() == "operator") {
                    if(isOverrideOperator(peek(2).getToken())) {
                        advance(2);
                        ast.add(current);
                        break;
                    }
                } else {
                    if(!expectIdentifier(ast)) break;

                    parseTemplateDecl(ast);
                }
                advance();
            }

            pushBack();
        } else
            pushBack();

             return true;
    }

    private def isNativeType(string type) : var {
        return type == "var" || type == "object"
               || type == "_int8" || type == "_int16"
               || type == "_int32" || type == "_int64"
               || type == "_uint8" || type == "_uint16"
               || type == "_uint32" || type == "_uint64";
    }

    public def expect(TokenType type, Ast ast, var[] msg) {
        advance();

        if(current.getType() == type) {
            ast.add(current);
        } else {
            errors.createNewError(CompilerError.GENERIC, current, "expected " + msg);
        }
    }

    public def expect(TokenType type, var[] msg) : var {
        advance();

        if(current.getType() == type) {
            return true;
        } else {
            errors.createNewError(CompilerError.GENERIC, current, "expected " + msg);
        }

        return false;
    }

    public def expectToken(Ast ast, var[] token) {

        if(current.getToken() != token) {
            errors.createNewError(CompilerError.GENERIC, current, "expected `" + token + "`");
        } else {
            ast.add(current);
        }
    }

    public def expectToken(Ast ast, var[] token, var[] msg) {

        if(current.getToken() != token) {
            errors.createNewError(CompilerError.GENERIC, current, "" + msg);
        } else {
            ast.add(current);
        }
    }

    private def pushBack() {
        if(cursor > 0) {
            current = tokenizer.get(--cursor);
        }
    }

    private def isAssignOperator(string token) : var {
        return token == "+=" || token == "-="||
               token == "*=" || token == "/="||
               token == "&=" || token == "|="||
               token == "^=" || token == "%="||
               token == "=";
    }

    private def isOverrideOperator(string token) : var  {
        return isAssignOperator(token) ||
               token == "++" ||token == "--" ||
               token == "*" || token == "/"  ||
               token == "%" || token == "-"  ||
               token == "+" || token == "==" ||
               token == "&&" || token == "||" ||
               token == ">>" || token == "<<" ||
               token == "<"  || token == ">"  ||
               token == "<=" || token == ">=" ||
               token == "!=";
    }

    def isExprSymbol(string token) : var {
        return token == "[" || token == "++" ||
               token == "--" || token == "*" ||
               token == "/" || token == "%" ||
               token == "-" || token == "+"||
               token == ">>" || token == "<<"||
               token == "<" || token == ">"||
               token == "<=" || token == ">="||
               token == "==" || token == "!="||
               token == "&" || token == "|"||
               token == "&&" || token == "||"||
               token == "^" || token == "?" ||
               isAssignOperator(token);
    }

    private def expectIdentifier(Ast ast) : var {
        advance();

        if(current.getId() == TokenId.IDENTIFIER && !isKeyword(current.getToken()))
        {
            ast.add(current);
            return true;
        } else {
            errors.createNewError(CompilerError.GENERIC, current, "expected identifier");
        }

        return false;
    }

    private def isKeyword(string key) : var {
        return key == "mod" || key == "true"
               || key == "false" || key == "class"
               || key == "static" || key == "protected"
               || key == "private" || key == "def"
               || key == "import" || key == "return"
               || key == "self" || key == "const"
               || key == "public" || key == "new"
               || key == "null" || key == "operator"
               || key == "base" || key == "if" || key == "while" || key == "do"
               || key == "try" || key == "catch"
               || key == "finally" || key == "throw" || key == "continue"
               || key == "goto" || key == "break" || key == "else"
               || key == "object" || key == "asm" || key == "for" || key == "foreach"
               || key == "var" || key == "sizeof"|| key == "_int8" || key == "_int16"
               || key == "_int32" || key == "_int64" || key == "_uint8"
               || key == "_uint16"|| key == "_uint32" || key == "_uint64"
               || key == "delegate" || key == "interface" || key == "lock" || key == "enum"
               || key == "switch" || key == "default";
    }

    private def peek(var forward) : TokenEntity {
        if((cursor+forward) >= tokenizer.size())
            return tokenizer.last();
        else
            return tokenizer.get(cursor+forward);
    }

    private def getAst(Ast ast, AstType type) : Ast {
        if(ast == null)
        {
            tree.add(new Ast(null, type, current.getLine(), current.getCol()));
            return tree.last();
        } else {
            ast.add(new Ast(ast, type, current.getLine(), current.getCol()));
            return ast.last();
        }
    }

    private def isDecl(TokenEntity token, var[] value) : var {
        return token.getId() == TokenId.IDENTIFIER && token.getToken() == value;
    }

    private def quit() : var {
        if(panic) return true;
        else if(errors.getRawErrorCount() > Options.maxErrors) {
            panic = true;
            return true;
        }

        return false;
    }

    private def parseAccessTypes() {
        accessTypes.clear();

        while(isAccessType(current))
        {
            accessTypes.add(current);
            advance();
        }
    }

    private def advance() {
        if((cursor+1) < tokenizer.size())
            current = tokenizer.get(++cursor);
        else current = tokenizer.last();
    }

    private def advance(var forward) {
        if((cursor+forward) < tokenizer.size()) {
            cursor += forward;
            current = tokenizer.get(cursor);
        } else current = tokenizer.last();
    }

    private def isAccessType(TokenEntity token) : var {
        return
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "protected" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "private" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "static" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "const" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "public";
    }

    private def isEnd() : var {
        return current.getType() == TokenType._EOF;
    }

    private static const var[] INTERFACE = "interface";
    private static const var[] MOD = "mod";
    private static const var[] CLASS = "class";
    private static const var[] IMPORT = "import";
    private static const var[] VAR = "var";
    private static const var[] OBJECT = "object";

    private string sourceFile = "";
    private var panic;
    private var cursor;
    private ArrayList<Ast> tree;
    private Dictionary<var, Ast> states;
    private ArrayList<string> lines;
    private TokenEntity current;
    private Tokenizer tokenizer;
    private string data = "";
    private ArrayList<TokenEntity> accessTypes;
    private ErrorManager errors;
}