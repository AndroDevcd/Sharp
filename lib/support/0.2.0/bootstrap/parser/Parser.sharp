mod app;

import std;

/**                          
* Created by bknun on 7/5/2018            
* Description:                             
*/
class Parser {
    public Parser(Tokenizer tokenizer)
    {
        self->tokenizer=tokenizer;

        if(tokenizer != null && tokenizer.getErrors() != null
            && !tokenizer.getErrors().hasErrors())
        {
            data = tokenizer.getData();
            accessTypes = new ArrayList<TokenEntity>();
            tree = new ArrayList<Ast>();
            states = new Dictionary<var, Ast>();
            lines = tokenizer.getLines();

            parse();
        }
    }

    private def parse() {
        sourceFile = tokenizer.getFile();
        errors = new ErrorManager(lines, sourceFile, false, Options.aggressiveErrors);
        current = tokenizer.get(cursor);


        while (!isEnd())
        {
            if(panic)
                break;

            if(isAccessType(current))
                parseAccessTypes();

            if(quit()) break;

            if(isEnd()) {
                accessTypes.clear();
                return;
            } else if(isDecl(current, MOD)) {
                if(accessTypes.size() > 0)
                    errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");
                parseModuleDecl(null);
            } else if(isDecl(current, CLASS)) {
                parseClassDecl(null);
            } else if(isDecl(current, METHOD)) {
                parseMethodDecl(null);
            } else if(isDecl(current, INTERFACE)) {
                parseInterfaceDecl(null);
            } else if(isDecl(current, ENUM)) {
                parseEnumDecl(null);
            } else if(isDecl(current, IMPORT)) {
                if(accessTypes.size() > 0)
                    errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");
                    
                parseImportDecl(null);
            } else if(isNativeType(current.getToken())) {
                parseVariableDecl(null);
            }else
            {
                // save parser state
                errors.enableProtectedMode();
                pushBack();

                var old = cursor+1;
                /*
                 * variable decl?
                 */
                if(parseUtype(null))
                {
                    cursor = old;
                    // gotdamn c++ we have to do this >:(
                    TokenEntity[] arry = tokenizer.getTokens();
                    current = arry[cursor];

                    errors.pass();
                    if(current.getId() == IDENTIFIER)
                    {
                        // Variable decliration
                        tree.popBack();
                        parseVariableDecl(null);
                        goto _continue;
                    }
                } else
                    errors.pass();

                tree.popBack();
                cursor = old;
                // gotdamn c++ we have to do this >:(
                TokenEntity[] arry = tokenizer.getTokens();
                current = arry[cursor];

                // "expected class, or import declaration"
                errors.createNewError(UNEXPECTED_SYMBOL, current, " `" + current.getToken() + "`; expected class, enum, method, interface, variable, or import declaration");
                parseAll(null);
            }

            _continue:
            advance();
            accessTypes.clear();
        }

        parsed = true;
    }

    private def parseClassDecl(Ast ast) {
        ast = getAst(ast, Class_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }

        accessTypes.clear();
        ast.add(current);
        expectIdentifier(ast);

        if(peek(1).getToken() == "<") {
            ast.setType(Generic_Class_Decl);

            expect(LESSTHAN, "`<`");
            parseIdentifierList(ast);
            expect(GREATERTHAN, "`>`");
        }

        if(peek(1).getToken() == "base") {
            advance();
            expectToken(ast, "base");
            parseReferencePointer(ast);
        }

        if(peek(1).getToken() == ":") {
            expect(COLON, "`:`");
            parseRefrenceIdentifierList(ast);
        }

        parseClassBlock(ast);
    }

    private def parseClassBlock(Ast ast) {
        expect(LEFT_CURLY, "`{` after class declaration");
        ast = getAst(ast, Class_Decl);

        var brackets = 1;
        while(!isEnd() && brackets > 0) {
            if(quit()) break;

            advance();
            if(isAccessType(current))
                parseAccessTypes();

            if(isDecl(current, MOD)) {
                if(accessTypes.size() > 0)
                     errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

                errors.createNewError(GENERIC, current, "unexpected module declaration");
                parseModuleDecl(ast);
            } else if(isDecl(current, CLASS)) {
                parseClassDecl(ast);
            } else if(isDecl(current, INTERFACE)) {
                parseInterfaceDecl(ast);
            } else if(isDecl(current, IMPORT))
            {
                if(accessTypes.size() > 0)
                     errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");
                errors.createNewError(GENERIC, current, "unexpected import declaration");
                parseImportDecl(ast);
            }
            else if(isNativeType(current.getToken()))
            {
                parseVariableDecl(ast);
            }
            else if(isDecl(current, PROTOTYPE))
            {
                parseProtoTypeDecl(ast, true);
            }
            else if(isDecl(current, ENUM))
            {
                parseEnumDecl(ast);
            }
            else if(isDecl(current, METHOD))
            {
                if(peek(1).getToken() == "operator")
                    parseOperatorDecl(ast);
                else if(peek(1).getToken() == "delegate")
                    parseDelegateDecl(ast);
                else
                    parseMethodDecl(ast);
            }
            else if(isConstructorDecl())
            {
                parseConstructor(ast);
            }
            else if(current.getType() == _EOF)
            {
                errors.createNewError(UNEXPECTED_EOF, current, "");
                break;
            }
            else if (current.getType() == RIGHT_CURLY)
            {
                if((brackets-1) < 0)
                {
                    errors.createNewError(ILLEGAL_BRACKET_MISMATCH, current, "");
                }
                else
                {
                    brackets--;

                    // end of class block
                    if(brackets == 0)
                    {
                        pushBack();
                        break;
                    }
                }
            }
            else if(current.getType() == LEFT_CURLY)
                brackets++;
            else {
                // save parser state
                retain(ast);
                pushBack();

                /*
                 * variable decl?
                 */
                if(parseUtype(ast))
                {
                    if(peek(1).getId() == IDENTIFIER)
                    {
                        // Variable decliration
                        rollbackLast(ast);
                        parseVariableDecl(ast);
                        accessTypes.clear();
                        continue;
                    }
                }

                rollback(ast);
                errors.createNewError(GENERIC, current, "expected method, class, or variable declaration");
                parseAll(ast);
            }

            accessTypes.clear();
        }

        if(brackets != 0)
            errors.createNewError(MISSING_BRACKET, current, " expected `}` at end of class declaration");

        expect(RIGHT_CURLY, "`}` at end of class declaration");
    }

    private def parseInterfaceDecl(Ast ast) {
        ast = getAst(ast, Interface_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }

        ast.add(current);
        expectIdentifier(ast);

        if(peek(1).getToken() == "<") {
            ast.setType(Generic_Interface_Decl);

            expect(LESSTHAN, "`<`");
            parseIdentifierList(ast);
            expect(GREATERTHAN, "`>`");
        }

        if(peek(1).getToken() == "base")
        {
            advance();
            expectToken(ast, "base");
            parseReferencePointer(ast);
        }

        parseInterfaceBlock(ast);
    }

    private def parseInterfaceBlock(Ast ast) {
        expect(LEFT_CURLY, "`{` after interface declaration");
        ast = getAst(ast, Block);

        var brackets = 1;
        while(!isEnd() && brackets > 0) {
            if(quit()) break;

            advance();

            if(isAccessType(current))
                parseAccessTypes();

            if(isDecl(current, MOD)) {
                if(accessTypes.size() > 0)
                     errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

                errors.createNewError(GENERIC, current, "unexpected module declaration");
                parseModuleDecl(ast);
            } else if(isDecl(current, INTERFACE)) {
                parseInterfaceDecl(ast);
            } else if(isDecl(current, IMPORT)) {
                 if(accessTypes.size() > 0)
                      errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

                 errors.createNewError(GENERIC, current, "unexpected import declaration");
                 parseImportDecl(ast);
            } else if(isDecl(current, VAR) || isDecl(current, OBJECT)) {
                 if(accessTypes.size() > 0)
                      errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

                 errors.createNewError(GENERIC, current, "unexpected variable declaration");
                 parseVariableDecl(ast);
            } else if(isDecl(current, PROTOTYPE)) {
                 if(accessTypes.size() > 0)
                      errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

                 errors.createNewError(GENERIC, current, "unexpected prototype declaration");
                 parseProtoTypeDecl(ast, false);
            }else if(isDecl(current, METHOD))
            {
                if(peek(1).getToken() == "operator") {
                    if(accessTypes.size() > 0)
                    {
                        errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");
                    }
                    errors.createNewError(GENERIC, current, "unexpected operator declaration");
                    parseOperatorDecl(ast);
                }
                else if(peek(1).getToken() == "delegate") {
                    parseDelegateDecl(ast);
                }
                else {
                    if(accessTypes.size() > 0)
                    {
                        errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");
                    }
                    errors.createNewError(GENERIC, current, "unexpected method declaration");
                    parseMethodDecl(ast);
                }
            }
            else if(isConstructorDecl())
            {
                if(accessTypes.size() > 0)
                {
                    errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");
                }
                errors.createNewError(GENERIC, current, "unexpected constructor declaration");
                parseConstructor(ast);
            }
            else if(current.getType() == _EOF)
            {
                errors.createNewError(UNEXPECTED_EOF, current, "");
                break;
            }
            else if (current.getType() == RIGHT_CURLY)
            {
                if((brackets-1) < 0)
                {
                    errors.createNewError(ILLEGAL_BRACKET_MISMATCH, current, "");
                }
                else
                {
                    brackets--;

                    // end of interface block
                    if(brackets == 0)
                    {
                        pushBack();
                        break;
                    }
                }
            }
            else if(current.getType() == LEFT_CURLY)
                brackets++;
            else {
                // save parser state
                retain(ast);
                pushBack();

                /*
                 * variable decl?
                 */
                if(parseUtype(ast))
                {
                    if(peek(1).getId() == TokenId.IDENTIFIER)
                    {
                        // Variable decliration
                        rollbackLast(ast);
                        parseVariableDecl(ast);
                        accessTypes.clear();
                        continue;
                    }
                }

                rollback(ast);
                errors.createNewError(GENERIC, current, "expected delegate prototype declaration");
                parseAll(ast);
            }

            accessTypes.clear();
        }

        if(brackets != 0)
            errors.createNewError(MISSING_BRACKET, current, " expected `}` at end of interface declaration");

        expect(RIGHT_CURLY, "`}` at end of interface declaration");
    }

    private def parseBlock(Ast ast) {
        var curly = false;
        if(peek(1).getToken() == "{") {
            expect(LEFT_CURLY, "`{`");
            curly = true;
        }

        ast = getAst(ast, Block);
        while(!isEnd())
        {
            if(quit()) break;

            advance();
            if (current.getType() == RIGHT_CURLY)
            {
                if(!curly)
                    errors.createNewError(GENERIC, current, "expected '{'");
                pushBack();
                break;
            }
            else if(current.getType() == LEFT_CURLY)
            {
                pushBack();
                parseBlock(ast);
            }
            else if(current.getType() == _EOF)
            {
                errors.createNewError(UNEXPECTED_EOF, current, "");
                break;
            }
            else {
                parseStatement(ast);

                if(!curly) {

                    accessTypes.clear();
                    break;
                }
            }

            accessTypes.clear();
        }

        if(curly)
            expect(RIGHT_CURLY, "`}`");
    }

    var commas=0;
    private def parseStatement(Ast ast) : var {
        ast = getAst(ast, Statement);
        if(quit()) return false;

        accessTypes.clear();
        if(isAccessType(current))
            parseAccessTypes();

        if(isDecl(current, RETURN))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseReturnStatement(ast);
            return true;
        }
        else if(isDecl(current, IF))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseIfStatement(ast);
            return true;
        }
        else if(isDecl(current, SWITCH))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseSwitchStatement(ast);
            return true;
        }
        else if(isDecl(current, ASSEMBLY))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseAssemblyStatement(ast);
            return true;
        }
        else if(isDecl(current, FOR))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseForStatement(ast);
            return true;
        }
        else if(isDecl(current, LOCK))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseLockStatement(ast);
            return true;
        }
        else if(isDecl(current, FOREACH))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseForEachStatement(ast);
            return true;
        }
        else if(isDecl(current, WHILE))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseWhileStatement(ast);
            return true;
        }
        else if(isDecl(current, DOWHILE))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseDoWhileStatement(ast);
            return true;
        }
        else if(isDecl(current, TRYCATCH))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseTryCatch(ast);
            return true;
        }
        else if(isDecl(current, THROW))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseThrowStatement(ast);
            return true;
        }
        else if(current.getToken() == "continue")
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            Ast tmp = getAst(ast, Continue_Statement);

            expectToken(tmp, "continue", "`continue`");
            expect(SEMICOLON, ast, "`;`");
            return true;
        }
        else if(current.getToken() == "break")
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            Ast tmp = getAst(ast, Break_Statement);

            expectToken(tmp, "break", "`break`");
            expect(SEMICOLON, tmp, "`;`");
            return true;
        }
        else if(current.getToken() == "goto")
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            Ast tmp = getAst(ast, Goto_Statement);

            expectToken(tmp, "goto", "`goto`");
            expectIdentifier(tmp); // TODO: add support for calling goto labels[9];
            expect(SEMICOLON, tmp, "`;`");
            return true;
        }
        else if(isNativeType(current.getToken()))
        {
            parseVariableDecl(ast);
            return true;
        }
        else if(isDecl(current, PROTOTYPE))
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            parseProtoTypeDecl(ast, true);
            return true;
        }
            /* these are just in case there is a missed bracket anywhere */
        else if(isDecl(current, MOD))
        {
            errors.createNewError(GENERIC, current, "module declaration not allowed here");
            parseModuleDecl(ast);
        }
        else if(isDecl(current, CLASS))
        {
            errors.createNewError(GENERIC, current, "unexpected class declaration");
            parseClassDecl(ast);
        }
        else if(isDecl(current, ENUM))
        {
            errors.createNewError(GENERIC, current, "enum declaration cannot be local");
            parseEnumDecl(ast);
        }
        else if(isDecl(current, INTERFACE))
        {
            errors.createNewError(GENERIC, current, "unexpected interface declaration");
            parseInterfaceDecl(null);
        }
        else if(isDecl(current, IMPORT))
        {
            errors.createNewError(GENERIC, current, "import declaration not allowed here (why are you putting this here LoL?)");
            parseImportDecl(ast);
        }
        else if(current.getType() == SEMICOLON)
        {
            if(accessTypes.size() > 0)
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

            /* we don't care about empty statements but we allow them */
            if(commas > 1) {
                commas = 0;
                errors.createNewWarning(GENERIC, current.getLine(), current.getCol(), "unnecessary semicolon ';'");
            } else
                commas++;
            return true;
        }
        else
        {
            // save parser state
            errors.enableProtectedMode();
            retain(ast);
            pushBack();

            /*
             * variable decl?
             */
            if(parseUtype(ast))
            {
                errors.pass();
                if(peek(1).getType() == COLON)
                {
                    if(accessTypes.size() > 0)
                        errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");

                    rollback(ast);
                    parseLabelDecl(ast);
                    return true;
                }
                else if(peek(1).getId() == IDENTIFIER)
                {
                    // Variable decliration
                    rollback(ast);
                    parseVariableDecl(ast);
                    return true;
                }
            } else
                errors.pass();

            rollback(ast);
            pushBack();

            errors.enableProtectedMode();
            retain(ast);
            if(!parseExpression(ast))
            {
                errors.pass();
                advance();
                errors.createNewError(GENERIC, ast, "not a statement");
                return false;
            } else {
                if(accessTypes.size() > 0)
                    errors.createNewError(ILLEGAL_ACCESS_DECLARATION, ast, "");

                errors.fail();
                dump();

                if(peek(1).getType() != SEMICOLON)
                    errors.createNewError(GENERIC, ast, "expected `;`");
                else
                    expect(SEMICOLON, ast, "`;`");
                return true;
            }
        }

        return false;
    }

    private def parseLabelDecl(Ast ast) {
        ast = getAst(ast, Label_Decl);

        pushBack();
        expectIdentifier(ast);
        expect(COLON, ast, "`:` after label declaration");

        if(peek(1).getType() == LEFT_CURLY)
            parseBlock(ast);
        else {
            advance();
            parseStatement(ast);
        }
    }

    private def parseEnumIdentifier(Ast ast) {
        ast = getAst(ast, Enum_Identifier);

        expectIdentifier(ast);

        if(peek(1).getType() == ASSIGN) {
            expect(ASSIGN, "`=`");

            parseValue(ast);
        }
    }

    private def parseEnumBlock(Ast ast) {
        ast = getAst(ast, Enum_Identifier_List);

        expect(LEFT_CURLY, "`{`");

        parseEnumIdentifier(ast);
        pRefPtr:
        if(peek(1).getType() == COMMA)
        {
            expect(COMMA, ast, "`,`");
            parseEnumIdentifier(ast);
            goto pRefPtr;
        }

        expect(RIGHT_CURLY, "`}`");
        expect(SEMICOLON, "`;`");
    }

    private def parseEnumDecl(Ast ast) {
        ast = getAst(ast, Enum_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }
        ast.add(current);


        expectIdentifier(ast);
        parseEnumBlock(ast);
    }

    private def parseThrowStatement(Ast ast) {
        ast = getAst(ast, Throw_Statement);

        expectToken(ast, "throw", "`throw`");
        parseExpression(ast);
        expect(SEMICOLON, ast, "`;`");
    }

    private def parseCatchClause(Ast ast) {
        ast = getAst(ast, Catch_Clause);

        advance();
        expectToken(ast, "catch", "`catch`");

        expect(LEFT_PAREN, ast, "`(`");
        parseUtypeArgOpt(ast);
        expect(RIGHT_PAREN, ast, "`)`");

        parseBlock(ast);
    }

    private def parseFinallyBlock(Ast ast) {
        ast = getAst(ast, Finally_Block);

        advance();
        expectToken(ast, "finally", "`finally`");
        parseBlock(ast);
    }

    private def parseTryCatch(Ast ast) {
        ast = getAst(ast, Trycatch_Statement);

        expectToken(ast, "try", "`try`");
        parseBlock(ast);

        while(peek(1).getToken() == "catch")
            parseCatchClause(ast);

        if(peek(1).getToken() == "finally")
        {
            parseFinallyBlock(ast);
        }
    }

    private def parseDoWhileStatement(Ast ast) {
        ast = getAst(ast, Do_While_Statement);

        expectToken(ast, "do", "`do`");
        parseBlock(ast);

        advance();
        expectToken(ast, "while", "`while`");
        expect(LEFT_PAREN, ast, "`(`");
        parseExpression(ast);
        expect(RIGHT_PAREN, ast, "`)`");

        expect(SEMICOLON, ast, "`;`");
    }

    private def parseWhileStatement(Ast ast) {
        ast = getAst(ast, While_Statement);

        expectToken(ast, "while", "`while`");

        expect(LEFT_PAREN, ast, "`(`");
        parseExpression(ast);
        expect(RIGHT_PAREN, ast, "`)`");

        parseBlock(ast);
    }

    private def parseForEachStatement(Ast ast) {
        ast = getAst(ast, Foreach_Statement);

        expectToken(ast, "foreach", "`foreach`");

        expect(LEFT_PAREN, ast, "`(`");
        parseUtypeArg(ast);

        expect(COLON, ast, "`:`");

        parseExpression(ast);
        expect(RIGHT_PAREN, ast, "`)`");

        parseBlock(ast);
    }

    private def parseLockStatement(Ast ast) {
        ast = getAst(ast, Lock_Statement);

        expectToken(ast, "lock", "`lock`");

        expect(LEFT_PAREN, ast, "`(`");
        parseExpression(ast);
        expect(RIGHT_PAREN, ast, "`)`");

        parseBlock(ast);
    }

    private def parseForStatement(Ast ast) {
        ast = getAst(ast, For_Statement);

        expectToken(ast, "for", "`for`");

        expect(LEFT_PAREN, ast, "`(`");

        if(peek(1).getType() != SEMICOLON) {
            parseUtypeArg(ast);
            parseValueAssignment(ast);
        }

        expect(SEMICOLON, ast, "`;`"); // The inititalizer

        if(peek(1).getType() != SEMICOLON) {
            parseExpression(ast);
            ast.last().setType(For_Expression_Cond);
        }
        expect(SEMICOLON, ast, "`;`");

        if(peek(1).getType() != RIGHT_PAREN) {
            parseExpression(ast);
            ast.last().setType(For_Expression_Iter);
        }
        expect(RIGHT_PAREN, ast, "`)`");

        parseBlock(ast);
    }

    private def parseAssemblyBlock(Ast ast) {
        ast = getAst(ast, Assembly_Block);

        if(peek(1).getId() == TokenId.STRING_LITERAL) {
            advance();
            ast.add(current);

            while(peek(1).getId() == TokenId.STRING_LITERAL) {
                advance();
                ast.add(current);
            }
        } else {
            errors.createNewError(GENERIC, current, "expected string literal");
        }
    }

    private def parseAssemblyStatement(Ast ast) {
        ast = getAst(ast, Assembly_Statement);

        expectToken(ast, "asm", "`asm`");
        if(peek(1).getToken() == VOLATILE) {
            advance();
            expectToken(ast, "volatile", "`volatile`");
        }

        expect(LEFT_PAREN, ast, "`(`");
        parseAssemblyBlock(ast);
        expect(RIGHT_PAREN, ast, "`)`");
        expect(SEMICOLON, ast, "`;`");
    }

    private def parseSwitchStatement(Ast ast) {
        ast = getAst(ast, Switch_Statement);

        expectToken(ast, "switch", "`switch`");

        expect(LEFT_PAREN, ast, "`(`");
        parseExpression(ast);
        expect(RIGHT_PAREN, ast, "`)`");

        parseSwitchBlock(ast);
    }

    private def parseSwitchDeclarator(Ast ast) {
        ast = getAst(ast, Switch_Declarator);
        advance();
        ast.add(current); // case | default

        if(ast.getToken(0).getToken() == "case")
            parseExpression(ast);

        expect(COLON, "`:`");

        retry:
        if(isSwitchDeclarator(peek(1)) || peek(1).getType() == RIGHT_CURLY) return;
        if(peek(1).getType() == LEFT_CURLY) {
            parseBlock(ast);
            goto retry;
        } else {
            advance();
            errors.enableProtectedMode();
            retain(ast);
            if(!parseStatement(ast))
            {
                errors.pass();
                rollbackLast(ast);
                return;
            } else {
                errors.fail();
                dump();
                goto retry;
            }
        }
    }

    private def parseSwitchBlock(Ast ast) {
        ast = getAst(ast, Switch_Block);

        expect(LEFT_CURLY, "`{`");

        if(isSwitchDeclarator(peek(1)))
        {
            parseSwitchDeclarator(ast);
            _pSwitchDecl:
            if(isSwitchDeclarator(peek(1)))
            {
                parseSwitchDeclarator(ast);
                goto _pSwitchDecl;
            }
        }

        expect(RIGHT_CURLY, "`}`");
    }

    private def isSwitchDeclarator(TokenEntity token) : var {
        return isDecl(token, CASE) || isDecl(token, DEFAULT);
    }

    private def parseIfStatement(Ast ast) {
        ast = getAst(ast, If_Statement);

        expectToken(ast, "if", "`if`");

        expect(LEFT_PAREN, ast, "`(`");
        parseExpression(ast);
        expect(RIGHT_PAREN, ast, "`)`");

        parseBlock(ast);

        Ast tmp;
        var isElse = false;
        condexpr:
        if(peek(1).getToken() == "else")
        {
            if(peek(2).getToken() == "if")
            {
                tmp = getAst(ast, Elseif_Statement);

                advance();
                tmp.add(current);
                advance();
                tmp.add(current);

                expect(LEFT_PAREN, tmp, "`(`");
                parseExpression(tmp);
                expect(RIGHT_PAREN, tmp, "`)`");
            }
            else
            {
                tmp = getAst(ast, Else_Statement);

                advance();
                tmp.add(current);
                isElse = true;
            }


            parseBlock(tmp);
            if(!isElse)
                goto condexpr;
        }
    }

    private def parseReturnStatement(Ast ast) {
        ast = getAst(ast, Return_Stmnt);

        ast.add(current);

        if(peek(1).getToken() != ";")
            parseValue(ast);

        expect(SEMICOLON, ast, "`;`");
    }

    private def parseAll(Ast ast) {
        if(isAccessType(current))
            parseAccessTypes();
        if(quit()) return;
        
        if(current.getType() == _EOF)
        {
            return;
        }
        else if(isDecl(current, METHOD))
        {
            if(peek(1).getToken() == "operator")
                parseOperatorDecl(ast);
            else if(peek(1).getToken() == "delegate")
                parseDelegateDecl(ast);
            else
                parseMethodDecl(ast);
        }
        else if(isDecl(current, MOD))
        {
            if(accessTypes.size() > 0)
            {
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");
            }
            parseModuleDecl(ast);
        }
        else if(isDecl(current, CLASS))
        {
            parseClassDecl(ast);
        }
        else if(isDecl(current, ENUM))
        {
            parseEnumDecl(ast);
        }
        else if(isDecl(current, INTERFACE))
        {
            parseInterfaceDecl(null);
        }
        else if(isDecl(current, IMPORT))
        {
            if(accessTypes.size() > 0)
            {
                errors.createNewError(ILLEGAL_ACCESS_DECLARATION, current, "");
            }
            parseImportDecl(ast);
        } else
            parseStatement(ast);
    }

    private def isConstructorDecl() : var {
        return current.getId() == TokenId.IDENTIFIER && !isKeyword(current.getToken()) &&
                   peek(1).getType() == LEFT_PAREN;
    }

    private def parseConstructor(Ast ast) {
        ast = getAst(ast, Constructor_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }
        accessTypes.clear();
        pushBack();

        expectIdentifier(ast);

        parseUtypeArgList(ast);
        parseBlock(ast);
    }

    private def parseMethodDecl(Ast ast) {
        ast = getAst(ast, Method_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }
        accessTypes.clear();
        ast.add(current);

        expectIdentifier(ast);

        parseUtypeArgList(ast);

        parseMethodReturnType(ast);
        parseBlock(ast);
    }

    private def parseDelegateDecl(Ast ast) {
        ast = getAst(ast, Delegate_Decl);

        for(var i = 0; i < accessTypes.size(); i++) {
            ast.add(accessTypes.get(i));
        }
        accessTypes.clear();
        ast.add(current);

        advance();
        expectToken(
                ast, "delegate", "`delegate`");

        expect(COLON, ast, "`:`");
        expect(COLON, ast, "`:`");
        expectIdentifier(ast);

        parseUtypeArgList(ast);
        parseMethodReturnType(ast); // assign-expr operators must return void
        if(peek(1).getType() == LEFT_CURLY)
        {
            parseBlock(ast);
        } else {
            expect(SEMICOLON, ast, "`;`");
            ast.setType(Delegate_Post_Decl);
        }
    }

    private def parseOperatorDecl(Ast ast) {
        ast = getAst(ast, Operator_Decl);

        TokenEntity[] arry = accessTypes.toArray();
        foreach(TokenEntity token : arry) {
            ast.add(token);
        }
        accessTypes.clear();
        ast.add(current);

        advance();
        expectToken(
                ast, "operator", "`operator`");

        advance();
        if(!isOverrideOperator(current.getToken()))
            errors.createNewError(GENERIC, current, "expected override operator");
        else
            ast.add(current);

        parseUtypeArgList(ast);
        parseMethodReturnType(ast); // assign-expr operators must return void

        parseBlock(ast);
    }

    private def parseProtoTypeDecl(Ast ast, var semicolon) {
        ast = getAst(ast, Func_Prototype);

        for(var i = 0; i < accessTypes.size(); i++) {
            ast.add(accessTypes.get(i));
        }
        accessTypes.clear();

        if(ast.tokenSize()>0)
            pushBack();

        if(!isDecl(current, PROTOTYPE))
            advance();
        expectToken(
                ast, "fn", "`fn`");

        expectIdentifier(ast);

        parseUtypeListOpt(ast);
        parseMethodReturnType(ast); // assign-expr operators must return void
        parserProtoTypeValueAssignment(ast);

        if(semicolon)
            expect(SEMICOLON, "`;`");
    }

    private def parserProtoTypeValueAssignment(Ast ast) {
        advance();
        if(isOverrideOperator(current.getToken()))
        {
            if(current.getToken() != "=") {
                errors.createNewError(GENERIC, current, "expected assign operator `=`");
            }
            ast.add(current);
            parseValue(ast);
        }
        else
            pushBack();
    }

    private def parseMethodReturnType(Ast ast) {
        if(peek(1).getType() == COLON)
        {
            ast = getAst(ast, Method_Return_Type);
            advance();

            ast.add(current);
            parseUtype(ast);
        }
    }

    private def parseImportDecl(Ast ast) {
        ast = getAst(ast, Import_Decl);
        ast.add(current);

        bool generic = false;
        parseModuleName(ast, generic);

        if(generic.getValue())
            errors.createNewError(GENERIC, current, "module-name does not allow for generic typing ");

        expect(SEMICOLON, ast, "`;`");
    }

    var partialDecl = 0;
    private def parseVariableDecl(Ast ast) {
        ast = getAst(ast, Var_Decl);

        if(partialDecl == 0) {
            TokenEntity[] arry = accessTypes.toArray();
            foreach(TokenEntity token : arry) {
                ast.add(token);
            }

            accessTypes.clear();
            pushBack();
            if(!parseUtype(ast))
                errors.createNewError(GENERIC, current, "expected native type or reference pointer");

        } else
            partialDecl--;

        expectIdentifier(ast);
        parseValueAssignment(ast);

        if(peek(1).getType() == COMMA) {
            partialDecl++;
            expect(COMMA, "`,`");

            parseVariableDecl(partialDecl <= 1 ? ast : ast.getParent());
        } else if(partialDecl == 0)
            expect(SEMICOLON, "`;`");
    }

    private def parseValueAssignment(Ast ast) {
        advance();
        if(isAssignOperator(current.getToken())) {
            ast.add(current);
            parseValue(ast);
        }
        else
            pushBack();
    }

    private def parseValue(Ast ast) : var {
        ast = getAst(ast, Value);
        return parseExpression(ast);
    }

    private def parseExpression(Ast ast) : var {
        ast = getAst(ast, Expression);
        if(quit()) return false;

        if(peek(1).getType() == _INC
            || peek(1).getType() == _DEC) {
            advance();
            ast.add(current);
            parseExpression(ast);
            ast.encapsulate(Pre_Inc_E);
            return true;
        }

        if(peek(1).getType() == LEFT_CURLY) {
            parseVectorArray(ast);
            ast.encapsulate(Vect_E);
            return true;
        }

        retain(ast);
        if(parsePrimaryExpression(ast)) {
            dump();
            if(!isOverrideOperator(peek(1).getToken()) && peek(1).getType() != QUESMK)
                return true;
        } else {
            rollbackLast(ast);
        }

        if(isAssignOperator(peek(1).getToken())) {
            advance();
            ast.add(current);

            parseExpression(ast);
            ast.encapsulate(Assign_E);

            if(!isOverrideOperator(peek(1).getToken()) && peek(1).getType() != QUESMK)
                return true;
        }

        var parsed = binary(ast);

        /* expression '?' expression ':' expression */
        if(peek(1).getType() == QUESMK)
        {
            advance();
            ast.add(current);

            parseExpression(ast);

            expect(COLON, ast, "`:`");

            parseExpression(ast);
            ast.encapsulate(Ques_E);
            return true;
        }

        return parsed;
    }

    private def binary(Ast ast) : var {
        var parsed = shift(ast);

        while(peek(1).getType() == AND || peek(1).getType() == XOR
            || peek(1).getType() == OR || peek(1).getType() == ANDAND
            || peek(1).getType() == OROR) {
            advance();
            ast.add(current);

            shift(ast);
            ast.encapsulate(And_E);
            parsed = true;
        }

        return parsed;
    }

    private def shift(Ast ast) : var {
        var parsed = equality(ast);

        while(peek(1).getType() == SHL
            || peek(1).getType() == SHR) {
            advance();
            ast.add(current);

            equality(ast);
            ast = ast.encapsulate(Shift_E);
            parsed = true;
        }

        return parsed;
    }

    private def equality(Ast ast) : var {
        var parsed = comparison(ast);

        while(peek(1).getType() == EQEQ
            || peek(1).getType() == NOTEQ) {
            advance();
            ast.add(current);

            comparison(ast);
            ast = ast.encapsulate(Equal_E);
            parsed = true;
        }

        return parsed;
    }

    private def comparison(Ast ast) : var {
        var parsed = addition(ast);

        while(peek(1).getType() == GREATERTHAN || peek(1).getType() == _GTE
            || peek(1).getType() == LESSTHAN || peek(1).getType() == _LTE) {
            advance();
            ast.add(current);

            ast = ast.encapsulate(Less_E);
            parsed = true;
        }

        return parsed;
    }

    private def addition(Ast ast) : var {
        var parsed = multiplication(ast);

        while(peek(1).getType() == MINUS || peek(1).getType() == PLUS) {
            advance();
            ast.add(current);

            multiplication(ast);
            ast = ast.encapsulate(Add_E);
            parsed = true;
        }

        return parsed;
    }

    private def multiplication(Ast ast) : var {
        var parsed = unary(ast);

        while(peek(1).getType() == _DIV || peek(1).getType() == _MOD
            || peek(1).getType() == MULT) {
            advance();
            ast.add(current);

            unary(ast);
            ast = ast.encapsulate(Mult_E);
            parsed = true;
        }

        return parsed;
    }

    private def unary(Ast ast) : var {
        if(peek(1).getType() == MINUS) {
            advance();
            ast.add(current);

            var parsed = unary(ast);
            ast = ast.encapsulate(Add_E);
            return parsed;
        } else if(peek(1).getType() == NOT) {
            advance();
            ast.add(current);

            var parsed = unary(ast);
            ast = ast.encapsulate(Not_E);
            return parsed;
        }

        retain(ast);
        errors.enableProtectedMode();
        if(!parsePrimaryExpression(ast))
        {
            errors.pass();
            rollbackLast(ast);
            return false;
        } else
        {
            dump();
            errors.fail();
            return true;
        }
    }

    private def parsePrimaryExpression(Ast ast) : var {
        ast = getAst(ast, Primary_Expression);

        errors.enableProtectedMode();
        retain(ast);
        if(parseLiteral(ast))
        {
            dump();
            errors.fail();
            ast.encapsulate(Literal_E);
            return true;
        }
        rollback(ast);
        errors.pass();

        errors.enableProtectedMode();
        if(peek(1).getType() == DOT) {
            advance();
            ast.add(current);
        }

        retain(ast);
        if(parseUtype(ast))
        {
            if(peek(1).getType() == DOT)
            {
                expect(DOT, ast.getChild(0), "`.`");
                advance();

                expectToken(ast.getChild(0), "class", "`class` after primary expression");

                dump();
                errors.fail();
                ast.encapsulate(Utype_Class_E);
                return true;
            } else
                rollback(ast);
        } else
            rollback(ast);
        errors.pass();

        if(peek(1).getToken() == "self")
        {
            advance();
            expectToken(ast, "self");

            if(peek(1).getType() == PTR) {
                expect(PTR, ast, "`->` after self");
                parseDotNotationCallExpression(ast);
            }

            ast.encapsulate(Self_E);
            return true;
        }

        if(peek(1).getToken() == "base")
        {
            advance();
            expectToken(ast, "base");
            expect(PTR, ast, "`->` after base");
            parseDotNotationCallExpression(ast);

            ast.encapsulate(Base_E);
            return true;
        }

        retain(ast);
        errors.enableProtectedMode();
        if(parseDotNotationCallExpression(ast)) {
            dump();
            errors.fail();
            ast.encapsulate(Dot_Not_E);
            if(!(peek(1).getType() == LEFT_BRACE ||
                peek(1).getType() == _INC
                || peek(1).getType() == _DEC))
                return true;
        } else {
            errors.pass();
            rollback(ast);
        }

        if(peek(1).getToken() == "new")
        {
            advance();
            expectToken(ast, "new");
            parseUtypeNaked(ast);
            var newClass = false;

            if(peek(1).getType() == LEFT_BRACE && parseArrayExpression(ast)){}
            else if(peek(1).getType() == LEFT_BRACE) {
                expect(LEFT_BRACE, ast, "`[`");
                expect(RIGHT_BRACE, ast, "`]`");
                parseVectorArray(ast);
            }
            else if(peek(1).getType() == LEFT_PAREN) {
                parseValueList(ast);
                newClass = true;
            }

            ast.encapsulate(New_E);
            if(peek(1).getType() != LEFT_BRACE) {
                if(newClass && peek(1).getType() == DOT)
                    parseDotNotationCallExpression(ast);
                return true;
            }
        }

        if(peek(1).getToken() == "sizeof")
        {
            advance();
            expectToken(ast, "sizeof");

            expect(LEFT_PAREN, ast, "`(`");
            parseExpression(ast);
            expect(RIGHT_PAREN, ast, "`)`");

            ast.encapsulate(Sizeof_E);
            return true;
        }

        if(peek(1).getType() == LEFT_PAREN)
        {
            retain(ast);
            errors.enableProtectedMode();

            advance();
            ast.add(current);

            if(!parseUtype(ast))
            {
                errors.pass();
                rollback(ast);
            } else {
                if(peek(1).getType() == RIGHT_PAREN)
                {
                    expect(RIGHT_PAREN, ast, "`)`");
                    if(!parseExpression(ast))
                    {
                        errors.pass();
                        rollback(ast);
                    } else
                    {
                        dump();
                        errors.fail();
                        ast.encapsulate(Cast_E);
                        return true;
                    }
                }else {
                    errors.pass();
                    rollbackLast(ast);
                }
            }

        }

        if(peek(1).getType() == LEFT_PAREN)
        {
            advance();
            ast.add(current);

            parseExpression(ast);

            expect(RIGHT_PAREN, ast, "`)`");

            if(!isExprSymbol(peek(1).getToken())) {
                retain(ast);
                errors.enableProtectedMode();
                if(parseDotNotationCallExpression(ast)) {
                    dump();
                    errors.fail();
                } else {
                    errors.pass();
                    rollbackLast(ast);
                }

                ast.encapsulate(Paren_E);
                return true;
            } else
                ast.encapsulate(Paren_E);

            if(peek(1).getType() != LEFT_BRACE)
                return true;
        }

        if(peek(1).getToken() == "null")
        {
            advance();
            expectToken(ast, "null");
            ast.encapsulate(Null_E);
            return true;
        }

        if(peek(1).getType() == LEFT_BRACE)
        {
            expect(LEFT_BRACE, ast, "`[`");
            parseExpression(ast);
            expect(RIGHT_BRACE, ast, "`]`");



            if(!isOverrideOperator(peek(1).getToken())){
                errors.enableProtectedMode();
                retain(ast);
                if(!parseDotNotationCallExpression(ast)) {
                    rollbackLast(ast);
                    errors.pass();
                }
                else {
                    errors.fail();
                    dump();
                }

                ast.encapsulate(Arry_E);
                return true;
            }
            ast.encapsulate(Arry_E);

            if(!(peek(1).getType() == _INC ||
                peek(1).getType() == _DEC))
                return true;
        }

        /* ++ or -- after the expression */
        if(peek(1).getType() == _INC ||
            peek(1).getType() == _DEC)
        {
            advance();
            ast.add(current);
            ast.encapsulate(Post_Inc_E);
            return true;
        }

        return false;
    }

    private def parseArrayExpression(Ast ast) : var {
        ast = getAst(ast, Array_Expression);

        retain(ast);
        errors.enableProtectedMode();
        expect(LEFT_BRACE, ast, "`[`");

        if(peek(1).getType() != RIGHT_BRACE) {
            if(!parseExpression(ast))
            {
                errors.pass();
                rollback(ast);
                return false;
            } else
            {
                dump();
                errors.fail();
            }
        } else {
            if (peek(2).getType() == LEFT_CURLY) {
                pushBack();
                return false;
            } else {
                dump();
                errors.fail();

                errors.createNewError(GENERIC, ast, "expected expression after '['");
                return false;
            }
        }

        expect(RIGHT_BRACE, ast, "`]`");
        return true;
    }

    private def parseDotNotationCallExpression(Ast ast) : var
    {
        ast = getAst(ast, Dotnotation_Call_Expr);

        if(peek(1).getType() == DOT)
        {
            advance();
            ast.add(current);
        }

        if(parseUtypeNaked(ast)) {
            if(peek(1).getType() == LEFT_PAREN) {
                parseValueList(ast);

                ast.encapsulate(Dot_Fn_E);
                /* func()++ or func()--
                 * This expression rule dosen't process correctly by itsself
                 * so we hav to do it ourselves
                 */
                if(peek(1).getType() == _INC || peek(1).getType() == _DEC)
                {
                    advance();
                    ast.add(current);
                }
                else if(peek(1).getType() == LEFT_BRACE) {
                    advance();
                    ast.add(current);

                    parseExpression(ast);
                    expect(RIGHT_BRACE, ast, "`]`");

                    if(peek(1).getType() == DOT)
                        parseDotNotationCallExpression(ast);
                }
                else {
                    if(peek(1).getType() == DOT)
                        parseDotNotationCallExpression(ast);
                }
            }
        } else {
            pushBack();
            return false;
        }

        return true;
    }

    private def parseValueList(Ast ast) {
        ast = getAst(ast, Value_List);

        expect(LEFT_PAREN, ast, "`(`");

        if(peek(1).getType() != RIGHT_PAREN)
        {
            parseValue(ast);

            _pValue:
            if(peek(1).getType() == COMMA)
            {
                expect(COMMA, ast, "`,`");
                if(!parseValue(ast)){
                    errors.createNewError(GENERIC, ast.last(), "expected value");
                }
                goto _pValue;
            }
        }

        expect(RIGHT_PAREN, ast, "`)`");
    }

    private def parseUtypeNaked(Ast ast) : var {
        ast = getAst(ast, Utype);

        if(parseTypeIdentifier(ast)) {
            return true;
        }
        else
            errors.createNewError(GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseLiteral(Ast ast) : var {
        ast = getAst(ast, Literal);

        TokenEntity token = peek(1);
        if(token.getId() == TokenId.CHAR_LITERAL || token.getId() == TokenId.INTEGER_LITERAL
            || token.getId() == TokenId.STRING_LITERAL || token.getId() == TokenId.HEX_LITERAL
            || token.getToken() == "true" || token.getToken() == "false")
        {
            advance();
            ast.add(current);
            return true;
        } else {
            errors.createNewError(GENERIC, current, "expected literal of type (string, char, hex, or bool)");
            return false;
        }
    }

    private def rollbackLast(Ast ast) {
        if(states.size() > 0) {
            cursor = states.lastKey();
            current = tokenizer.get(cursor);

            if(ast.childrenSize() == 1) {
                ast.clear();
            } else
                ast.popChild();

            states.drop();
        }
    }

    private def rollback(Ast ast) {
        if(states.size() > 0) {
            cursor = states.lastKey();
            current = tokenizer.get(cursor);
            Ast tmp = states.lastValue();
            ast.copy(tmp);

            states.drop();
        }
    }

    private def dump() {
        if(states.size() > 0)
            states.removeAt(states.size()-1);
    }

    private def dump(var setCursor) {
        if(states.size() > 0) {
            var old = states.lastKey();

            if(setCursor)
                cursor = old;
            states.drop();
        }
    }

    private def retain(Ast ast) {
        Ast copy = new Ast();
        copy.copy(ast);
        states.put(cursor, copy);
    }

    private def parseVectorArray(Ast ast) {
        ast = getAst(ast, Vector_Array);
        expect(LEFT_CURLY, ast, "`{`");

        if(peek(1).getType() != RIGHT_CURLY) {
            parseExpression(ast);
            _pExpr:
            if(peek(1).getType() == COMMA)
            {
                expect(COMMA, ast, "`,`");
                parseExpression(ast);
                goto _pExpr;
            }
        }

        expect(RIGHT_CURLY, ast, "`}`");
    }

    private def parseIdentifierList(Ast ast) {
        ast = getAst(ast, Identifier_List);

        expectIdentifier(ast);
        pRefPtr:
        if(peek(1).getType() == COMMA) {
            expect(COMMA, ast, "`,`");
            expectIdentifier(ast);
            goto pRefPtr;
        }
    }

    private def parseRefrenceIdentifierList(Ast ast) {
        ast = getAst(ast, Identifier_List);

        parseReferencePointer(ast);
        pRefPtr:
        if(peek(1).getType() == COMMA) {
            expect(COMMA, ast, "`,`");
            parseReferencePointer(ast);
            goto pRefPtr;
        }
    }

    private def parseModuleDecl(Ast ast) {
        ast = getAst(ast, Module_Decl);
        ast.add(current);

        bool generic = false;
        parseModuleName(ast, generic);

        if(generic.getValue())
            errors.createNewError(GENERIC, current, "module-name does not allow for generic typing ");

        expect(SEMICOLON, ast, "`;`");
    }

    private def parseModuleName(Ast ast, bool generic) {
        parseModuleName(ast, generic, false);
    }


    private def parseModuleName(Ast ast, bool generic, var local) {
        if(!local)
            ast = getAst(ast, ModuleName);

        if(peek(1).getToken() == "operator") {
            if(isOverrideOperator(peek(2).getToken())) {
                advance(2);
                ast.add(current);
                return;
            }
        }else {
            expectIdentifier(ast);
            generic = parseTemplateDecl(ast);
        }

         advance();
         while(current.getType() == DOT) {
             if(peek(1).getToken() == CLASS)
                 break;

             ast.add(current);

             if(peek(1).getToken() == "operator") {
                 if(isOverrideOperator(peek(2).getToken())) {
                     advance(2);
                     ast.add(current);
                     advance();
                     break;
                 }
             } else {
                 if(expectIdentifier(ast)){
                     if(parseTemplateDecl(ast))
                         generic = true;
                 }
             }
             advance();
         }

         pushBack();
    }

    private def parseTemplateDecl(Ast ast) : var {
        if(peek(1).getType() == LESSTHAN) {
            advance();
            retain(ast);

            if(peek(1).getType() == GREATERTHAN) {
                errors.createNewError(GENERIC, current, "expected identifier before `>`");
                advance();
                return true;
            }

            if(parseUtype(ast) && (peek(1).getType() == GREATERTHAN || peek(1).getType() == COMMA))
            {
                rollbackLast(ast);
                errors.pass();
                parseUtypeList(ast);
                if(peek(1).getType() == GREATERTHAN) {
                    expect(GREATERTHAN, ast, "`>`");
                    ast.popToken();
                } else
                    expect(GREATERTHAN, ast, "`>`");

                return true;
            } else
                dump();

            errors.pass();
            pushBack();
        }

        getAst(ast, None);
        return false;
    }

    private def parseUtypeListOpt(Ast ast) {
        ast = getAst(ast, Utype_Arg_List_Opt);
        expect(LEFT_PAREN, ast, "`(`");

        if(peek(1).getType() != RIGHT_PAREN)
        {
            if(isDecl(peek(1), PROTOTYPE))
                parseProtoTypeDecl(ast, false);
            else
                parseUtypeArgOpt(ast);
            _puTypeArgOpt:
            if(peek(1).getType() == COMMA)
            {
                expect(COMMA, ast, "`,`");

                if(isDecl(peek(1), PROTOTYPE))
                    parseProtoTypeDecl(ast, false);
                else
                    parseUtypeArgOpt(ast);
                goto _puTypeArgOpt;
            }
        }

        expect(RIGHT_PAREN, ast, "`)`");
    }


    private def parseUtypeArgList(Ast ast) {
        ast = getAst(ast, Utype_Arg_List);
        expect(LEFT_PAREN, ast, "`(`");

        if(peek(1).getType() != RIGHT_PAREN)
        {
            if(isDecl(peek(1), PROTOTYPE))
                parseProtoTypeDecl(ast, false);
            else
                parseUtypeArg(ast);
            _puTypeArg:
            if(peek(1).getType() == COMMA)
            {
                expect(COMMA, ast, "`,`");

                if(isDecl(peek(1), PROTOTYPE))
                    parseProtoTypeDecl(ast, false);
                else
                    parseUtypeArg(ast);
                goto _puTypeArg;
            }
        }

        expect(RIGHT_PAREN, ast, "`)`");
    }

    private def parseUtypeArg(Ast ast) : var {
        ast = getAst(ast, Utype_Arg);

        if(parseUtype(ast))
        {
            expectIdentifier(ast);
            return true;
        }else
            errors.createNewError(GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseUtypeArgOpt(Ast ast) : var {
        ast = getAst(ast, Utype_Arg_Opt);

        if(parseUtype(ast))
        {
            if(peek(1).getId() == IDENTIFIER)
                expectIdentifier(ast);

            return true;
        }else
            errors.createNewError(GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseUtypeList(Ast ast) {
        ast = getAst(ast, Utype_List);

        parseUtype(ast);
        pRefPtr:
        if(peek(1).getType() == COMMA)
        {
            expect(COMMA, ast, "`,`");
            parseUtype(ast);
            goto pRefPtr;
        }
    }

    private def parseUtype(Ast ast) : var {
        ast = getAst(ast, Utype);

        if(parseTypeIdentifier(ast))
        {
            if(peek(1).getType() == LEFT_BRACE)
            {
                advance();
                ast.add(current);

                expect(RIGHT_BRACE, ast, "`]`");
            }

            return true;
        } else
            errors.createNewError(GENERIC, current, "expected native type or reference pointer");

        return false;
    }

    private def parseTypeIdentifier(Ast ast) : var {
        ast = getAst(ast, Type_Identifier);
        advance();

        if(!isNativeType(current.getToken()))
            pushBack();
        else {
            ast.add(current);
            return true;
        }

        errors.enableProtectedMode();
        if(!parseReferencePointer(ast)) {
            errors.pass();
        } else {
            errors.fail();
            return true;
        }

        return false;
    }

    private def parseReferencePointer(Ast ast) : var {
        ast = getAst(ast, Reference_Pointer);

        advance();
        if(current.getId() == TokenId.IDENTIFIER && isKeyword(current.getToken())) {
            if(current.getToken() != "operator") {
                return false;
            }
            else
                pushBack();
        } else if(current.getId() == TokenId.IDENTIFIER)
            pushBack();
        else {
            pushBack();
            return false;
        }

        bool generic = false;
        parseModuleName(ast, generic, true);

        advance();
        if(current.getType() == HASH) {
            if(generic)
                errors.createNewError(GENERIC, current, "module-name does not allow for generic typing ");
            ast.add(current);

            if(expectIdentifier(ast)) {
                parseTemplateDecl(ast);
                advance();
            }

            while(current.getType() == DOT ) {
                if(peek(1).getToken() == CLASS)
                    break;

                ast.add(current);

                if(peek(1).getToken() == "operator") {
                    if(isOverrideOperator(peek(2).getToken())) {
                        advance(2);
                        ast.add(current);
                        break;
                    }
                } else {
                    if(!expectIdentifier(ast)) break;

                    parseTemplateDecl(ast);
                }
                advance();
            }

            pushBack();
        } else
            pushBack();

        return true;
    }

    private def isNativeType(string type) : var {
        return type == "var" || type == "object";
    }

    public def expect(TokenType type, Ast ast, var[] msg) {
        advance();

        if(current.getType() == type) {
            ast.add(current);
        } else {
            errors.createNewError(GENERIC, current, "expected " + msg);
        }
    }

    public def expect(TokenType type, var[] msg) : var {
        advance();

        if(current.getType() == type) {
            return true;
        } else {
            errors.createNewError(GENERIC, current, "expected " + msg);
        }

        return false;
    }

    public def expectToken(Ast ast, var[] token) {

        if(current.getToken() != token) {
            errors.createNewError(GENERIC, current, "expected `" + token + "`");
        } else {
            ast.add(current);
        }
    }

    public def expectToken(Ast ast, var[] token, var[] msg) {

        if(current.getToken() != token) {
            errors.createNewError(GENERIC, current, "expected " + msg);
        } else {
            ast.add(current);
        }
    }

    private def pushBack() {
        if(cursor > 0) {
            current = tokenizer.get(--cursor);
        }
    }

    private def isAssignOperator(string token) : var {
        return token == "+=" || token == "-="||
               token == "*=" || token == "/="||
               token == "&=" || token == "|="||
               token == "^=" || token == "%="||
               token == "=";
    }

    private def isOverrideOperator(string token) : var  {
        return isAssignOperator(token) ||
               token == "++" ||token == "--" ||
               token == "*" || token == "/"  ||
               token == "%" || token == "-"  ||
               token == "+" || token == "==" ||
               token == "&&" || token == "||" ||
               token == ">>" || token == "<<" ||
               token == "<"  || token == ">"  ||
               token == "<=" || token == ">=" ||
               token == "!=";
    }

    def isExprSymbol(string token) : var {
        return token == "[" || token == "++" ||
               token == "--" || token == "*" ||
               token == "/" || token == "%" ||
               token == "-" || token == "+"||
               token == ">>" || token == "<<"||
               token == "<" || token == ">"||
               token == "<=" || token == ">="||
               token == "==" || token == "!="||
               token == "&" || token == "|"||
               token == "&&" || token == "||"||
               token == "^" || token == "?" ||
               isAssignOperator(token);
    }

    private def expectIdentifier(Ast ast) : var {
        advance();

        if(current.getId() == TokenId.IDENTIFIER && !isKeyword(current.getToken()))
        {
            ast.add(current);
            return true;
        } else {
            errors.createNewError(GENERIC, current, "expected identifier");
        }

        return false;
    }

    private def isKeyword(string key) : var {
        return key == "mod" || key == "true"
               || key == "false" || key == "class"
               || key == "static" || key == "protected"
               || key == "private" || key == "def"
               || key == "import" || key == "return"
               || key == "self" || key == "const"
               || key == "public" || key == "new"
               || key == "null" || key == "operator"
               || key == "base" || key == "if" || key == "while" || key == "do"
               || key == "try" || key == "catch"
               || key == "finally" || key == "throw" || key == "continue"
               || key == "goto" || key == "break" || key == "else"
               || key == "object" || key == "asm" || key == "for" || key == "foreach"
               || key == "var" || key == "sizeof"|| key == "_int8" || key == "_int16"
               || key == "_int32" || key == "_int64" || key == "_uint8"
               || key == "_uint16"|| key == "_uint32" || key == "_uint64"
               || key == "delegate" || key == "interface" || key == "lock" || key == "enum"
               || key == "switch" || key == "default" || key == "volatile" || key == "fn";
    }

    private def peek(var forward) : TokenEntity {
        if((cursor+forward) >= tokenizer.size())
            return tokenizer.last();
        else
            return tokenizer.get(cursor+forward);
    }

    private def getAst(Ast ast, AstType type) : Ast {
        if(ast == null)
        {
            tree.add(new Ast(null, type, current.getLine(), current.getCol()));
            return tree.last();
        } else {
            ast.add(new Ast(ast, type, current.getLine(), current.getCol()));
            return ast.last();
        }
    }

    public def getErrors() : ErrorManager {
        return errors;
    }

    private def isDecl(TokenEntity token, var[] value) : var {
        return token.getId() == TokenId.IDENTIFIER && token.getToken() == value;
    }

    private def quit() : var {
        if(panic) return true;
        else if(errors.getRawErrorCount() > Options.maxErrors) {
            panic = true;
            return true;
        }

        return false;
    }

    private def parseAccessTypes() {
        accessTypes.clear();

        while(isAccessType(current))
        {
            accessTypes.add(current);
            advance();
        }
    }

    private def advance() {
        if((cursor+1) < tokenizer.size())
            current = tokenizer.get(++cursor);
        else current = tokenizer.last();
    }

    private def advance(var forward) {
        if((cursor+forward) < tokenizer.size()) {
            cursor += forward;
            current = tokenizer.get(cursor);
        } else current = tokenizer.last();
    }

    private def isAccessType(TokenEntity token) : var {
        return
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "protected" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "private" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "static" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "const" ||
                    token.getId() == TokenId.IDENTIFIER && token.getToken() == "public";
    }

    private def isEnd() : var {
        return current.getType() == _EOF;
    }

    private static const var[] INTERFACE = "interface";
    private static const var[] MOD = "mod";
    private static const var[] CLASS = "class";
    private static const var[] IMPORT = "import";
    private static const var[] VAR = "var";
    private static const var[] OBJECT = "object";
    private static const var[] PROTOTYPE = "fn";
    private static const var[] METHOD = "def";
    private static const var[] RETURN = "return";
    private static const var[] IF = "if";
    private static const var[] SWITCH = "switch";
    private static const var[] ASSEMBLY = "asm";
    private static const var[] FOR = "for";
    private static const var[] LOCK = "lock";
    private static const var[] FOREACH = "foreach";
    private static const var[] WHILE = "while";
    private static const var[] DOWHILE = "do";
    private static const var[] TRYCATCH = "try";
    private static const var[] CATCH = "catch";
    private static const var[] THROW = "throw";
    private static const var[] CONTINUE = "continue";
    private static const var[] BREAK = "break";
    private static const var[] GOTO = "goto";
    private static const var[] CASE = "case";
    private static const var[] DEFAULT = "default";
    private static const var[] VOLATILE = "volatile";
    private static const var[] ENUM = "enum";

    private string sourceFile = "";
    private var panic;
    private var cursor;
    private var parsed;
    private ArrayList<Ast> tree;
    private Dictionary<var, Ast> states;
    private ArrayList<string> lines;
    private TokenEntity current;
    private Tokenizer tokenizer;
    private string data = "";
    private ArrayList<TokenEntity> accessTypes;
    private ErrorManager errors;
}