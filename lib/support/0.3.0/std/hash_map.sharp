mod std;

import ( std.math )

/**
* Created by bknun on 9/5/2022
*
* @class hash_map
*
* Description:
*
*/
class hash_map<k base _object_, v base _object_> {
    data: entry<k, v?>[];
    threshold := 0.75;
    max_size := 96;
    size : var;

    private static const default_capacity := 128;
    public hash_map(initialCapacity: int) {
        data = new entry<k,v?>[initialCapacity.value];
        max_size = (sizeof(data) * threshold);
    }

    public hash_map() {
        data = new entry<k,v?>[default_capacity];
    }

    def set_threshold(threshold: int) {
        self->threshold = threshold.value;
        max_size = (sizeof(data) * threshold.value);
    }

    private def hash(key: k) : int {
        return abs(key.hash() % sizeof(data));
    }

    private def resize() {
        old_data : entry<k, v?>[]? = data;
        data = new entry<k,v?>[sizeof(old_data) + (sizeof(old_data) >> 1)];
        max_size = sizeof(data) * threshold;
        foreach(entry in old_data)
        {
            while(entry != null) // todo fix this this is wrong i think
            {
                next := entry.next;
                index : var = hash(entry.key).value;
                entry.next = data[index];
                data[index] = entry;
                entry = next;
            }
        }

        old_data = null;
    }

    public def at(key: k) : v? {
        index: var = hash(key).value;
        initialHash := -1;
        no_value : v;

        if(data[index] == null) {
            return no_value;
        } else {
            entry := data[index];
            while(entry != null && entry.key != key
                && entry.next != null)
                entry = entry.next;

            if (entry == null)
                return no_value;
            else
                return entry.value;
        }
    }

    public def put(key: k, value: v?) : bool {
        index: var = hash(key).value;
        prev : entry<k,v?>;
        entry := data[index];

        while (entry != null && entry.key != key) {
            prev = entry;
            entry = entry.next;
        }

        if(entry == null) {
            size++;
            entry =  new entry<k,v?>(key, value);
            if(prev == null) {
                data[index] = entry;
            } else {
                prev.next = entry;
            }

            return true;
        } else {
            entry.value = value;
            return false;
        }
    }

    public def remove(key: k) : bool {
        index := hash(key).value;
        if(data[index] == null) {
            prev_entry: entry<k,v?>?;
            entry : entry<k,v?>? = data[index];
            while(entry != null && entry!!.key != key) {
                prev_entry = entry;
                entry = entry!!.next;
            }

            if(entry!!.key == key) {
                if(prev_entry == null) {
                    next_entry := entry!!.next;
                    data[index] = next_entry;
                } else {
                    next_entry := entry!!.next;
                    prev_entry!!.next = next_entry;
                    entry = null;
                }

                return true;
            }
        }

        return false;
    }

    class entry<k, v> {
        protected key: k;
        protected value: v?;
        protected next: entry<k, v?>;

        public entry(key: k, value: v?) {
            self->key = key;
            self->value = value;
        }

        public def to_string() : string {
            return "key " + key + " value " + value?.to_string();
        }
    }
}
