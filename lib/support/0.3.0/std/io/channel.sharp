mod std.io;

import (
    std.io.fiber,
    std
)

/*
    [Master]
       [0] *[item]
       [1]  [2]
       [2]  [item] [item] [item] ...
       [3]  *[] [] []
       [4]

       index
          * = blocking
*/

class channel<t> : receive_channel<t>, send_channel<t>, loopable<t> {

    protected filters : list<filter<t> >;
    protected buff_type : buffer_type;
    protected capacity := 0;
    protected state := channel_state.OPEN;

    static const default_capacity := 10;
    static const DEFAULT_FILTER := 0;

    private channel() {}

    channel(capacity : int) {
       add_filters(1);
       set_capacity(capacity);
    }

    channel(capacity : int, filters: int) {
       add_filters(filters);
       set_capacity(capacity);
    }

    private def set_capacity(capacity: int) {
        if(capacity.value > 0) {
           self->capacity = capacity.value;
           if(capacity.value == 1) {
              buff_type = SINGLE;
           } else {
              buff_type = BUFFERED;
           }
        } else {
           throw new ill_state_except("channel capacity cannot be < 0");
        }
    }

    channel(buff_type : buffer_type) {
       add_filters(1);
       set_buff_type(buff_type);
    }


    channel(buff_type : buffer_type, filters: int) {
       add_filters(filters);
       set_buff_type(buff_type);
    }

    private def set_buff_type(buff_type: buffer_type) {
       self->buff_type = buff_type;
       when (buff_type) {
          EXCLUSIVE, SINGLE -> {
              capacity = 1;
          }
          UNLIMITED -> {
             capacity = -1;
          }
          BUFFERED -> {
             capacity = default_capacity;
          }
       }
    }

    private def add_filters(filter_count : int) {
      if(filter_count.value <= 0) {
         throw new ill_state_except("channels must have at least 1 filter");
      }

      filters = new list<filter<t> >(filter_count);
      for(i := 0; i < filter_count.value; i++) {
         filters.add(new filter<t>());
      }
    }

    def get_capacity() := capacity;
    def get_buffer_type() := buff_type;
    def is_closed() : bool {
       lock(self) {
          return state == channel_state.CLOSED;
       }
    }

    override def send(data : t) {
       send(data, DEFAULT_FILTER);
    }

    override def send(data : t, filter: int) {
       if(filter.value >= filters.size().value || filter.value < 0) {
          throw new bounds_except("invalid send on filter ($filter) when max filter is ${filters.size()}");
       }

       filters[filter].send(data, self);
    }

    override def read() : t {
       return read(DEFAULT_FILTER);
    }

    override def read(filter: int) : t {
       if(filter.value >= filters.size().value || filter.value < 0) {
          throw new bounds_except("invalid send on filter ($filter) when max filter is ${filters.size()}");
       }

       return filters[filter].read(self);
    }

    override def close() {
       lock(self) {
          state = channel_state.CLOSED;
       }
    }

    override def open() {
       lock(self) {
           state = channel_state.OPEN;
       }
    }

    override def read_next(filter: int, count: int) : list<t> {
       if(filter.value >= filters.size().value || filter.value < 0) {
          throw new bounds_except("invalid read on filter ($filter) when max filter is ${filters.size()}");
       }

       data := new list<t>();
       filtered_channel := filters[filter];

       for(i : var = 0; i < count.value; i++) {
          filtered_channel.wait_for_data_or_close(self);

          if(state == channel_state.OPEN) {
             data.add(filtered_channel.read(self));
          }
       }

       return data;
    }

    override def read_next(filter: int) : list<t> {
       if(filter.value >= filters.size().value || filter.value < 0) {
          throw new bounds_except("invalid read on filter ($filter) when max filter is ${filters.size()}");
       }

       filtered_channel := filters[filter.value];
       if(filtered_channel.avail_data() == 0) {
          return new list<t>();
       }

       data := new list<t>();
       lock(filtered_channel) {
          for(;;) {
             if(state == channel_state.CLOSED) return data;

             if(filtered_channel.avail_data()) {
                data.add(filtered_channel.read(self));
             } else {
                return data;
             }
          }
       }

       return new list<t>();
    }

    override def read_all(filter: int) : list<t> {
       if(filter.value >= filters.size().value || filter.value < 0) {
          throw new bounds_except("invalid read on filter ($filter) when max filter is ${filters.size()}");
       }

       data := new list<t>();
       filtered_channel := filters[filter.value];

       for(;;) {
          filtered_channel.wait_for_data_or_close(self);

          if(state == channel_state.OPEN && filtered_channel.avail_data()) {
             data.add(filtered_channel.read(self));
          }
       }

       return new list<t>();
    }

    override def next() : int {
       for(;;) {
          if(state == channel_state.CLOSED)
             return -1;

          for(i : var = 0; i < filters.size().value; i++) {
             if(filters[i].avail_data()) {
                return i;
             }
          }

          delay(2);
       }

       return 0;
    }

    override def get_elements() : t[]? {
       return read_all(DEFAULT_FILTER).get_elements();
    }

    override def avail_data(filter: int) : bool {
        if(filter.value >= filters.size().value || filter.value < 0) {
           throw new bounds_except("invalid read on filter ($filter) when max filter is ${filters.size()}");
        }

        filtered_channel := filters[filter.value];
        return filtered_channel.avail_data();
    }

    enum channel_state {
         OPEN,
         CLOSED
    }

    def get_state() := state;

    def size() : int = filters[0].buff_size;

    class filter<t> {
       head : channel_data<t>?;
       tail : channel_data<t>?;
       buff_size : var;

       def filo() : t? {
          data := head?.data;
          head = head?.next;
          if(head == null)
             tail = null;
          return data;
       }

       private def wait_for_data() {
          while(buff_size == 0) { delay(0); }
       }

       private def wait_for_consume() {
          while(buff_size != 0) { delay(0); }
       }

       def wait_for_data_or_close(chan: channel<t>) {
          if(buff_size == 0) {
             while(buff_size == 0) {
                if(chan.get_state() == channel<t>.channel_state.CLOSED)
                   break;

                delay(0); // yield task
             }
          }
       }

       def avail_data() : bool {
          return buff_size;
       }

       def read(chan: channel<t>) : t {
          when(chan.buff_type) {
             EXCLUSIVE -> {
                wait_for_data();

                lock(self) {
                    data := head?.data;
                    tail = null;
                    head = null;
                    buff_size = 0;
                    return data!!;
                }
             }
             SINGLE -> {
                wait_for_data();

                data := head?.data;
                buff_size = 0;
                return data!!;
             }
             UNLIMITED -> {
                wait_for_data();

                lock(self) {
                    buff_size--;
                    data := filo();
                    return data!!;
                }
             }
             BUFFERED -> {
                wait_for_data();

                lock(self) {
                    buff_size--;
                    data := filo();
                    return data!!;
                }
             }
             else -> {
                no_value : t;
                return no_value;
             }
          }
       }

       def send(data : t, chan: channel<t>) {
          if(chan.get_state() == channel<t>.channel_state.OPEN) {
             when(chan.buff_type) {
                EXCLUSIVE -> {
                   lock(self) {
                       head = new channel_data<t>(data);
                       tail = head;
                       buff_size = 1;
                   }
                   wait_for_consume();
                   return;
                }
                SINGLE -> {
                   if(head == null) {
                      head = new channel_data<t>(data);
                      tail = head;
                   } else {
                      head?.data = data;
                   }

                   buff_size = 1;
                }
                UNLIMITED -> {
                   lock(self) {
                       if(head == null) {
                          head = new channel_data<t>(data);
                          tail = head;
                       } else {
                          tail?.next = new channel_data<t>(data);
                          tail = tail?.next;
                       }

                       buff_size++;
                   }
                }
                BUFFERED -> {
                    while(buff_size == chan.capacity) { delay(0); }

                    lock(self) {
                        if(head == null) {
                           head = new channel_data<t>(data);
                           tail = head;
                           buff_size++;
                        } else {
                           tail?.next = new channel_data<t>(data);
                           tail = tail?.next;
                           buff_size++;
                        }
                    }
                }
             }
          }
       }

        class channel_data<t> {
            channel_data(data: t) {
                self->data = data;
            }

            data : t;
            next : channel_data<t>;
        }
    }
}


