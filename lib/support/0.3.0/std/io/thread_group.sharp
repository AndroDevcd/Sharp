mod std.io;

public class thread_group : loopable<thread> {
	
	public thread_group(name : string) {
		self->name = name;
		self->default_priority = thread_priority.norm_priority;
	}
	
	public thread_group(name : string, priority : thread_priority) {
		self->name = name;
		self->default_priority = priority;
	}
	
	def at(id : int) := handles.at(id);
	
	def add(t : thread) {
	    lock(self) {
	        index := handles.indexof(t);
            if(index >= 0) {
               handles.put(index, t);
            } else {
               handles.add(t);
               n_threads++;
            }
		}
	}
	
	def size() := n_threads;
	def get_name() := name;
	def get_priority() := default_priority;
	def remove(id : int) : bool {
	    lock (self) {
	        _thread := find(id);
            if(_thread != null) {
                handles.remove(_thread!!);
                n_threads--;
                return true;
            }

            return false;
		}
	}

    override def get_elements() : thread[] {
        return handles.get_elements()!!;
    }

    def find(find_func: (thread)(bool)) : thread? {
	    lock (self) {
           for(i := 0; i < handles.size().value; i++) {
               _thread := handles.at(i);
               if(_thread != null && find_func(_thread)) {
                   return _thread;
               }
           }

           return null;
        }
    }

    def find(id: int) : thread? {
	    lock (self) {
           for(i := 0; i < handles.size().value; i++) {
               if(handles[i].get_id() == id) {
                   return handles[i];
               }
           }

           return null;
        }
    }
	
	def kill_all() {
	    lock (self) {
		   foreach(t in handles) {
		   	  t.interrupt();
		   }
		}
	}
	
	public static main_group := new thread_group("main");
	private handles := new list<thread>();
	private name : string;
	private default_priority : thread_priority;
	private n_threads := 0;
}