mod std.io;

/**
 * UnixFileSystem represents the high level version of the operations
 * that you can invoke on a linux file system. Not much needs to be changed in
 * this file other than normalizing the path name
 */
protected class unix_fs base file_system {
    private slash := '/';
    private buffer := new char[512];

    override def path_separator() : char {
        return slash;
    }

    /**
    * Make sure we know that our path has the correct
    * path seperators to be accessed
    */
    override def normalize(pathname: string) : string {
        lock(self) {
           n := pathname.size();
           buf_index := 0;
           for (i : var = 0; i < n; i++) {
               // remove any trailing slashes
               if((i + 1) >= n && buf_index > 0 && (pathname[i] == '\\' || pathname[i] == '/'))
                   break;

               // Remove duplicate slashes.
               if (pathname[i] == '\\') {
                   if(buf_index > 0 && buffer[buf_index - 1] != '/')
                       buffer[buf_index++] = new char('/');

                   if(((i + 1) < n) && pathname[i + 1] == '\\') {
                       do {
                           i++;
                       } while(pathname[i] == '\\');
                       i--;
                   }
               }
               else if(pathname[i] == '/')  {
                   if(((i + 1) < n) && pathname[i + 1] == '/') {
                       do {
                           i++;
                       } while(pathname[i] == '/');

                       if(buf_index > 0 && buffer[buf_index - 1] != '/')
                           i--;
                   }

                   if(buf_index == 0 || buf_index > 0 && buffer[buf_index - 1] != '/')
                       buffer[buf_index++] = new char('/');
               }
               else
                   buffer[buf_index++] = pathname[i];
           }

           path_buf := new char[buf_index];
           for(i : var = 0; i < (buf_index); i++) {
               path_buf[i] = buffer[i];
           }
           return new string(path_buf, 0, buf_index);
        }
    }

     /**
      * Return the simple boolean attributes for the file or directory denoted
      * by the given abstract pathname, or zero if it does not exist or some
      * other I/O error occurs.
      */
     override def get_attributes(f: file) : int {
        path := f.path.data;
        attrs := 0;

        /*
        * This will perform the os call to request the
        * file attributes of the given abstract pathname
        */
        asm {
            pushl [path]
            int 0x25
            smovr2 [attrs], ebx
        };

        return attrs;
     }


     /**
      * Check whether the file or directory denoted by the given abstract
      * pathname may be accessed by this process.  The second argument specifies
      * which access, ACCESS_READ, ACCESS_WRITE or ACCESS_EXECUTE, to check.
      * Return false if access is denied or an I/O error occurs
      */
     override def check_access(f: file, access: int) : int {
        path := f.path.data;
        _access := access.value;
        result := 0;

        /*
        * This will perform the os call to request the
        * file access stats of the given abstract pathname
        */
        asm {
            pushl [path]
            loadl ebx, [_access]
            int 0x24
            smovr2 [result], ebx
        };

        return result;
     }
}
