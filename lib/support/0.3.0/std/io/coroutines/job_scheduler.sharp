mod std.io.coroutines;

import (
    platform.kernel,
    std.math,
    std.io,
    std.io.fiber
)

private short_term_threads := new atomic<int>(0);
private long_term_threads := new atomic<int>(0);
private max_threads : var = 0;
private scheduler : thread?;
private task_thread_lock := false;

private const FIBER_THRESHOLD_TRIGGER  : var = 4; // create a new thread after 15 fibers

public def start_scheduler() {
    lock(launcher) {
         if(scheduler == null) {
            if(max_threads == 0)
                calculate_max_threads();
            scheduler = new thread("job_scheduler", scheduler_main, launcher.long_term_pool);
            scheduler!!.start(null);
        }
	}
}

private def calculate_max_threads() {
    n_cores : var = vm.hardware_concurrency().value;
    n_cores -= 2;

    if(n_cores <= 1) {
        short_term_threads = 1;
    } else {
        short_term_threads = round(n_cores * 0.75);
        long_term_threads = round(n_cores * 0.25);
    }

    if(short_term_threads == 0)
        short_term_threads = 1;

    if(long_term_threads == 0)
        long_term_threads = 1;

    max_threads = (short_term_threads + long_term_threads.read()).value;
}

def set_thread_max(max: int) {
    lock(launcher) {
        if(task_thread_lock) {
            throw new ill_arg_except("cannot modify max thread count after task library has started, " +
             "try calling this before your first task");
        }

        if(max >= 2) {
            if(max > 2) {
                short_term_threads = round((max * 0.75).to_double());
                long_term_threads = round((max * 0.25).to_double());
            }

            if(short_term_threads == 0)
                short_term_threads = 1;

            if(long_term_threads == 0)
                long_term_threads = 1;

            max_threads = max.value;
        } else {
            throw new ill_arg_except("cannot have less than 2 max threads");
        }
    }
}

def get_thread_max() : int {
    lock(launcher) {
        if(max_threads == 0)
            calculate_max_threads();
        return max_threads;
    }
}

def run_scheduler() {
	jobs := launcher.job_queue;
	canceled_jobs := launcher.canceled_job_queue;
	const SLEEP_TIME : var = 2;
	const SPIN_COUNT : var = 60000 / SLEEP_TIME;
	spins_left : var = SPIN_COUNT;
	cancel_list := new list<int>();

    while(true)
    {
        when {
            canceled_jobs.avail_data(0) -> {
                foreach(tag in canceled_jobs.read_next(0)) {
                   cancel_list.add(tag);
                }
            }

            jobs.avail_data(0) -> {
                foreach(scheduled_job in jobs.read_next(0)) {
                   if(!cancel_list.empty()) {
                      if(cancel_list.find(scheduled_job.tag, { it, it2 -> return it == it2; }) == scheduled_job.tag)
                         continue;
                   }

                   if(scheduled_job.state == cancelled)
                      continue;

                   if(!execute_job(scheduled_job)) {
                   	   jobs.send(scheduled_job);
                   }
                }

                cancel_list.clear();
            }
        }

        if(spins_left-- <= 0) {
            spins_left = SPIN_COUNT;
            kill_threads();
        }

    	delay(SLEEP_TIME);
    }
}

total := 0, started = 0;
public def scheduler_main(args : object[]) : int
{
    run_scheduler();
	return 0;
}

localized avail_threads : var;
localized host : thread?;
excuse localized pool : thread_group;
private def get_host(long_running : bool) : thread? {
    localized pool : thread_group;
    
	if(long_running) {
		pool = launcher.long_term_pool;
	} else
		pool = launcher.short_term_pool;

    avail_threads = 0;
    host = null;
    pool.find({ t ->
        if(t == scheduler) return false;

        fibers := fiber.poll(t);
        if(!t.is_active() || fibers >= 1) {
            avail_threads++;

            if(host != null && fiber.poll(host) > fibers) {
               host = t;
            }
            else if(host == null) host = t;
        }

        return false;
    });

    if(host != null && ((fiber.poll(host) >= FIBER_THRESHOLD_TRIGGER))) {
       if((long_running && long_term_threads > 0) || short_term_threads > 0) {
           host = null;
       }
    }


    // can we creat a new host?
    if(host == null) {
        if(long_running) {
            if(long_term_threads > 0) {
                long_term_threads--;
                host = new thread("long_term_worker_thread#${pool.size()+1}", job.job_main, pool);
                host!!.start();
            }
        } else {
            if(short_term_threads > 0) {
                short_term_threads--;
                host = new thread("worker_thread#${pool.size()+1}", job.job_main, pool);
                host!!.start();
            }
        }
    }

	return host;
}

private def kill_threads() {
	if(max_threads < 3)
	   return;

	pool = launcher.long_term_pool;

    avail_threads = 0;
    pool.find({ t ->
        if(t == scheduler) return false;

        if(!t.is_active() || fiber.poll(t) > 1)
           avail_threads++;

        return false;
    });

	if(avail_threads < 1)
	   return;

    host =
        pool.find({ t ->
            if(t == scheduler) return false;

            return t.is_active() && fiber.poll(t) == 1; // kill any threads idling
        });

    // kill unused threads
    host?.interrupt();
	pool = launcher.short_term_pool;

    avail_threads = 0;
    pool.find({ t ->
            if(!t.is_active() || fiber.poll(t) > 1)
               avail_threads++;

            return false;
        });

	if(avail_threads < 1)
	   return;

    host =
        pool.find({ t ->
            return t.is_active() && fiber.poll(t) == 1; // kill any threads idling for more than 3 minutes
        });

    // kill unused threads
    host?.interrupt();
}

protected def execute_synchronous(scheduled_job : job) {
    task_thread_lock := true;
	if(scheduled_job.delay_time != 0) {
		future := scheduled_job.delay_time - time.mills_time();
	}
    delay(scheduled_job.delay_time);
	scheduled_job.execute();
}

protected def execute_job(scheduled_job : job) : bool {
    task_thread_lock := true;
    fib_host := scheduled_job.host == null ? get_host(scheduled_job.long_term)
           	    : scheduled_job.host;

    if(fib_host != null) {
        scheduled_job.host = fib_host;
        result := scheduled_job.execute_async();

        if(result != 0) {
           scheduled_job.host = null;
           return false;
        }

        started++;
        return true;
    } else {
        return false;
    }
}

