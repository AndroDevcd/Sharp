mod std.io.coroutines;

import (
    std.io,
    std.io.fiber
)

public class job {

	private job() {}

	job(name : string) {
		self->name = name;
		self->tag = rand_int();
	}

	protected def execute_async() : int {
		if(state == created) {
            if(!host?.is_active()) {
                if(host?.start() != result_ok)
                {
                  return 2;
                }
            }

            running_host : thread?;
            if(!unconfined) running_host = host;

            slice({ args: object[] -> (int)
               schdj := args[0] as job;
               schdj.execute();
               return 0;
            }, running_host!!, new object[]{ self });
            return 0;
		} else if(state == active) {
			return 1;
		}

		return 2;
	}

	public def cancel() {
	    lock(self) {
            if(state == active) {
                state = cancelled;
                if(fiber.current() != fib) {
                   fib.kill();
                   launcher.cleanup_job(self);
                }
                else {
                   throw new cancellation_exception();
                }
            } else if(state == created) {
                state = cancelled;
            }
	    }
	}

	protected def cancel_future() {
	    lock(self) {
            if(recurring) {
                jb := next_task;
                while(jb != null) {
                    jb?.cancel();
                    launcher.cleanup_job(jb!!);

                    jb = jb?.next_task;
                }
            }
		}
	}

	public def join() {
	    if(block_caller
	        || state == cancelled
	        || state == completed)
	        return;

        while(!is_finished()) {
           delay(0);
        }
	}

	public def get_state() := state;
	public def get_name() := name;
	public def get_tag() := tag;

	protected def operator=(block: ()()) {
		self->main0 = block;
	}

	protected def operator=(block: (args : object[])()) {
		main1 = block;
	}

	protected def operator=(block: (deferred : object, args : object[])()) {
		main2 = block;
	}

	protected def operator=(block: (deferred : object)()) {
		main3 = block;
	}

	protected static def job_main(args : object[]) : int {
        for(;;) { // instead add a "perma lock" here with a mutex to be more efficent
            delay(10000);
        }
        return 0;
	}

	protected def execute() {
	    start_time = time.mills_time();
		launcher.add_job(self);
		state = active;

		try {
		   if(recurring)
		       reschedule();

           when {
               main0 != 0 -> main0();
               main1 != 0-> main1(args!!);
               main2 != 0 -> main2(deferred_obj!!, args!!);
               main3 != 0 -> main3(deferred_obj!!);
           }

		   state = completed;
		   launcher.cleanup_job(self);
		} catch(cancellation_exception) {
            state = cancelled;
            launcher.cleanup_job(self);
        } catch(t: throwable) {
           state = cancelled;
           launcher.cleanup_job(self);
           if(!block_caller)
		      fib.current().unbind(); // protect against crashing the thread
		   throw t;
		}
	}

    def is_finished() := state == completed || state == cancelled;
    def is_active() := state == active;

    public def update_interval(tm: long, interval: time_unit) {
        if(!recurring)
	        throw new ill_state_except("cannot set update restart interval on non-recurring job");

        if(state == active) {
           cancel_future();
           next_task = null;
        }

        if(interval == nanoseconds) {
            sched_time = time.nano_to_mills(tm);
        } else if(interval == microseconds) {
            sched_time = tm / 1000;
        } else if(interval == milliseconds) {
            sched_time = tm;
        } else if(interval == seconds) {
            sched_time = tm * 1000;
        }

        if(state == active)
           reschedule();
    }

    protected def reschedule() {

        delay := (start_time + sched_time) - time.mills_time().value;
        jb := coroutine.builder()
            .with_name(name!!)
            .recurring(sched_time, milliseconds);

        user_args := new object[sizeof(args) - 1];
        index := 0;
        for(i := 1; i < sizeof(args); i++) {
            user_args[index++] = args[i];
        }

        if(long_term)
            jb.long_term();
        jb.with_args(user_args);

        when {
            main0 != 0 -> jb.scheduled_job.main0 = main0;
            main1 != 0 -> jb.scheduled_job.main1 = main1;
            main2 != 0 -> jb.scheduled_job.main2 = main2;
            main3 != 0 -> jb.scheduled_job.main3 = main3;
        }

        if(delay > 0)
           jb.schedule(delay);

        next_task = jb.scheduled_job;
        jb.master.start_job(jb.scheduled_job);
    }

	protected main0: ()();
	protected main1: (args : object[])();
	protected main2: (object, object[])();
	protected main3: (object)();
	protected host : thread?;
	protected fib : fiber;
	protected name : string?;
	protected args : object[]?;
	protected deferred_obj : object?;
	protected start_time : long = 0;
	protected sched_time : long = 0;
	protected delay_time : long = 0;
	protected next_task : job?;
	protected recurring := false;
	protected tag : int = 0;
	protected block_caller := false;
	protected long_term := false;
	protected unconfined := false;
	protected state := created;
}