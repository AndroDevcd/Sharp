mod std;

/**
* Created by bknun on 9/3/2022
* 
* @class synced_list
*
* Description:
* This class serves as the "thread safe" version of @class list<T>
*/
class synced_list<T base _object_> : loopable<T> {
    private n_elements : var;
    private data : T[]?;
    private is_compact: var;

    private static const default_capacity := 10;
    private static const min_capacity := 128;

    synced_list() {
        data = new T[default_capacity];
    }

    synced_list(starting_capacity: int) {
        data = new T[starting_capacity.value];
    }

    def set_compact(compact_array: int) {
        lock(self) {
            is_compact = compact_array.value;
        }
    }

    override def get_elements() : T[]? {
        lock(self) {
            if(n_elements == 0) return null;
            else return copy(data!!, 0, n_elements) as T[];
        }
    }

    def operator[](index: int): T {
        lock(self) {
            if(index.value >= n_elements || index.value < 0) // todo: if end type is bool class for if, for, while, do-while etc pull value fields out
                throw new bounds_except(out_of_bounds_msg(index));
            return data[index];
        }
    }

    def at(index: int): T {
        lock(self) {
            if(index.value >= n_elements || index.value < 0)
                throw new bounds_except(out_of_bounds_msg(index));
            return data[index];
        }
    }

    def last(): T {
        return at(n_elements - 1);
    }

    def put(index: int, element: T) : T {
        lock(self) {
            if (index.value >= n_elements || index.value < 0)
                throw new bounds_except(out_of_bounds_msg(index));

            old_val := data[index.value];
            data[index.value] = element;
            return old_val;
        }
    }

    private def expand() {
        if(is_compact) {
            realloc(data!!, sizeof(data) + min_capacity);
        } else
            realloc(data!!, sizeof(data) + (sizeof(data) >> 4) + min_capacity);
    }

    def clear() {
        lock(self) {
            if(n_elements > 0) {
                data = new T[default_capacity];
                n_elements = 0;
            }
        }
    }

    def pop_last() : T {
        lock(self) {
            item := last();
            pop_back();
            return item;
        }
    }

    def pop_first() : T {
        lock(self) {
            if(n_elements > 0) {
                item := data[0];
                remove_at(0);
                return item;
            } else {
                throw new bounds_except(out_of_bounds_msg(index)); // todo: ensure that this sets code path returns a value for compiler
            }
        }
    }

    def add_all(lst: list<T>) {
        lock(self) {
            data = copy(lst.get_elements()!!, 0, lst.size()) as T[];
            n_elements = lst.size();
        }
    }

    def add(element: T) {
        lock(self) {
            if(n_elements >= sizeof(data))
                expand();
            data[n_elements++] = element;
        }
    }

    def indexof(element: T) : var {
        lock(self) {
            for(i := 0; i < n_elements; i++) {
                if(element == data[i]) {
                    return i;
                }
            }

            return -1;
        }
    }

    def pop_back() {
        lock(self) {
            if(n_elements > 0) {
                excuse no_val : T;
                data[--n_elements] = no_val;
            }
        }
    }

    def size() : int {
        lock(self) {
            return n_elements;
        }
    }

    def empty() : bool {
        lock(self) {
            return n_elements==0;
        }
    }

    def insert(index: int, element: T) {
        lock(self) {
            if(index.value > n_elements || index.value < 0)
               throw new bounds_except(out_of_bounds_msg(index));

            if(n_elements == 0) {
                add(element);
            } else {
               if(n_elements >= sizeof(data))
                   expand();
               n_elements++;
                for(i := n_elements - 1; i > index.value; i--)
                   data[i] = data[i-1];
                data[index.value] = element;
            }
        }
    }


    def remove(val: T) {
        lock(self) {
            for(i := 0; i < n_elements; i++) {
                if(val == data[i]) {
                    remove_at(i);
                    return;
                }
            }
        }
    }

    def remove(val: T, compare_fun: (T, T)(bool)) {
        lock(self) {
            for(i : var = 0; i < n_elements; i++) {
                if(compare_fun(val, data[i])) {
                    remove_at(i);
                    return;
                }
            }
        }
    }

    def remove_at(index: int) {
        lock(self) {
            if(index.value >= n_elements || index.value < 0)
               throw new bounds_except(out_of_bounds_msg(index));

            num_moved := n_elements - index.value - 1;
            if (num_moved > 0)
                memcopy(data!!, data!!, index, index.value+1, n_elements);

            pop_back();
        }
    }

    def indexof(comparer: T, find_func: (T, T)(bool)) : var {
        lock(self) {
            for(i : var = 0; i < n_elements; i++) {
                if(find_func(data[i], comparer)) {
                    return i;
                }
            }

            return -1;
        }
    }

    def linear_sort(swap: (T, T)(bool)) {
        lock(self) {
            for(i : var = 0; i < n_elements; i++) {

                for (j : var = 0; j < n_elements; j++) {
                    if((j + 1) < n_elements) {

                        if (swap(data[j], data[j+1])) {
                            tmp := data[j];
                            data[j] = data[j+1];
                            data[j+1] = tmp;
                        }
                    }
                }
            }
        }
    }

    def find(comparer : T, find_func: (T, T)(bool)) : T? {
        lock(self) {
            for(i : var = 0; i < n_elements; i++) {
                if(find_func(data[i], comparer)) {
                    return data[i];
                }
            }

            return null;
        }
    }

    def replace(val: T, compare_fun: (T, T)(var)) : var {
        lock(self) {
            for(i : var = 0; i < n_elements; i++) {
                if(compare_fun(val, data[i])) {
                    data[i] = val;
                    return true;
                }
            }

            return false;
        }
    }

    def to_string() : string {
        lock(self) {
            str := new string_builder();

            str += "[ ";
            for(i := 0; i < n_elements; i++) {
                str += data[i];

                if((i + 1) < n_elements) {
                    str += ", ";
                }
            }

            str += " ]";
            return str.to_string();
        }
    }

    private def out_of_bounds_msg(index: int) : string {
        return "Index: $index, size: $n_elements";
    }
}
