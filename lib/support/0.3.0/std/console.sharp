mod std;

import (
    platform.kernel
)

def strtod(str: string) : double {
    data := str.data;
    result : var;

    asm {
        pushl [data]
        int 0x43
        smovr2 [result], ebx
    }

    return result;
}

def strtol(str: string, base_num: int) : long {
    data := str.data;
    result := base_num.value;

    asm {
        pushl [data]
        ipushl [result]
        int 0x50
        smovr2 [result], ebx
    }

    return result;
}

def snprintf(fmt: int, num: double, precision: int) : string {
    result : _int8[]? = null;
    _fmt := fmt.value;
    _num := num.value;
    _precision := precision.value;
    asm {
        loadl egx, [_fmt]
        loadl ebx, [_num]
        loadl ecx, [_precision]
        int 0x1
        movl [result]
        popObj
    }
    return new string(result);
}

def sys(str: string) : int {
    cmd := str.data;
    result : var;
    asm {
        pushl [cmd]
        int 0x1a
        smovr2 [result], cmt
    }

    return result;
}

def print(data: _int8[]) {
    print_chars(data);
}

def print(str: string) {
    print_chars(str.data);
}

def println(data: var[]) {
    print_numbers(data);
    print_char('\n');
}

def println(data: _int8[]) {
    print_chars(data);
    print_char('\n');
}

def println(data: _int16[]) {
    print_numbers(data);
    print_char('\n');
}

def println(data: _int32[]) {
    print_numbers(data);
    print_char('\n');
}

def println(data: _int64[]) {
    print_numbers(data);
    print_char('\n');
}

def println(data: _uint8[]) {
    print_numbers(data);
    print_char('\n');
}

def println(data: _uint16[]) {
    print_numbers(data);
    print_char('\n');
}

def println(data: _uint32[]) {
    print_numbers(data);
    print_char('\n');
}

def println(data: _uint64[]) {
    print_numbers(data);
    print_char('\n');
}

def println(data: var) {
    print_num(data);
    print_char('\n');
}

def println() {
    print_char('\n');
}

def println(e: _enum_) {
    print_chars(e.name);
    print_char('\n');
}

def read_line() : string {
    ch : char;
    message : string = "";

    ch = read_char();
    while((ch != 13) && (ch != 10)) { // \r\n
        message.append(ch);
        ch = read_char();
    }

    flush();
    return message;
}

def read_passwd() : string {
    ch : char;
    message : string = "";

    ch = read_raw_char();
    while((ch != 13) && (ch != 10)) { // \r\n
        message.append(ch);
        ch = read_raw_char();
    }

    flush();
    return message;
}

def read_char() : char {
    return read_ch(true);
}

def read_raw_char() : char {
    return read_ch(false);
}

def println(str: string) {
    print_chars(str.data);
    print_char('\n');
}

def println(o: printable?) {
    print_chars(o?.to_string()?.data ?: "null");
    print_char('\n');
}

def print(o: printable?) {
    print_chars(o?.to_string()?.data ?: "null");
}

def print(data: double) {
    print_num(data);
}

def flush() {
    asm { int 0x34 }
}

def utc_mills() : long {
    return time.mills_time();
}

def nano_time() : long {
    return time.nano_time();
}

def exit(val : int) {
    vm.exit(val.value);
}

def exit() {
    vm.exit(0);
}

def sizeOf(data: object) : long {
    result : var;

    asm {
        pushl [data]
        int 0x33
        smovr2 [result], ebx
    }
    return result;
}

def sizeOf(data: object[]) : long {
    result : var;

    asm {
        pushl [data]
        int 0x33
        smovr2 [result], ebx
    }

    return result;
}

local def print_chars(str: char_array) {
    foreach(ch in str) {
        asm {
            loadl ebx, [ch]
            putc ebx
        }
    }

    flush();
}

local def print_num(val: double) {
    _val := val.value;

    asm {
        loadl ebx, [_val]
        put ebx
    }

    flush();
}

local def print_char(val: char) {
    _val := val.value;

    asm {
        loadl ebx, [_val]
        putc ebx
    }

    flush();
}

local def print_numbers(str: char_array) {
    asm {
        movi ebx, '['
        movi egx, ' '
        putc ebx
        putc egx
    }
    for(i := 0; i < sizeof(str); i++) {
        ch := str.data[i];
        asm {
            loadl ebx, [ch]
            put ebx
        }

        if((i + 1) < sizeof(str)) {
            asm {
                movi ebx, ','
                movi egx, ' '
                putc ebx
                putc egx
            }
        }
    }

    asm {
        movi ebx, ' '
        movi egx, ']'
        putc ebx
        putc egx
    }

    flush();
}

local def print_numbers(str: _int16[]) {
    print_numbers(str);
}

local def print_numbers(str: _int32[]) {
    print_numbers(str);
}

local def print_numbers(str: _int64[]) {
    print_numbers(str);
}

local def print_numbers(str: _uint8[]) {
    print_numbers(str);
}

local def print_numbers(str: _uint16[]) {
    print_numbers(str);
}

local def print_numbers(str: _uint32[]) {
    print_numbers(str);
}

local def print_numbers(str: _uint64[]) {
    print_numbers(str);
}

local def print_chars(str: _int16[]) {
    print_chars(str);
}

local def read_ch(echo: var) : char {
    result  : var = 0;

    asm {
        loadl cmt, [echo]
        get ebx
        smovr2 [result], ebx
    }

    return result;
}

