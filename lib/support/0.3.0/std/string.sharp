mod std;

import (
    std.io
)

/**
* Created by bknun on 9/3/2022
* 
* @class string
*
* Description:
* This class serves as a wrapper over the native type _int8[]
* to allow for extended functionality with some string building/processing
* support
*/
class string : loopable<_int8> {
    data : _int8[]?;
        private set value -> { data = value; }

    string(str : _int8[]?) {
        if(str != null) {
            append(str!!);
        }
    }

    init(str : _int8[]) {
       append(str);
    }

    string(ch: _int8) {
        append(ch);
    }

    string(str : char[]) {
        if(str != null) {
            data = new _int8[sizeof(str)];
            iter : var = 0;
            foreach(ch in str) {
                data[iter++] = ch.value;
            }
        }
    }

    string(str: string) {
        if(str != null && str.data != null) {
            append(str.data!!);
        }
    }

    string(str : _int8[], offset: int) {
       data = copy(str, offset.value, sizeof(str));
    }

    string(str : char[], start: int, end: int) {
        if((end.value - start.value) > 0) {
            data = new _int8[end.value - start.value];
            array := new char_array(str).get_elements();
            memcopy(array!!, data!!, 0, start.value, end.value);
        }
    }

    string(str : _int8[], start: int, end: int) {
        if((end.value - start.value) > 0) {
            data = new _int8[end.value - start.value];
            memcopy(str, data!!, 0, start.value, end.value);
        }
    }

    def replace(pos : int, ch: char) : string {
        if(pos.value >= sizeof(data)) {
            throw bounds_error(pos);
        }

        data[pos.value] = ch.value;
        return self;
    }

    def append(ch: char) : string
    {
        if(data == null)
            data = new _int8[1];
        else
            realloc(data!!, sizeof(data) + 1);

        data[sizeof(data) - 1] = ch.value;
        return self;
    }

    def empty() : bool = sizeof(data)==0;

    def append(immstr: _int8[]?) : string
    {
        if(immstr == null) return self;

        old_size : var = sizeof(data);

        if(data == null)
            data = new _int8[sizeof(immstr)];
        else
            realloc(data!!, sizeof(data) + sizeof(immstr));

        memcopy(immstr!!, data!!, old_size, 0, sizeof(immstr));
        return self;
    }

    def append(immstr: _int8[]?, len: int) : string
    {
        if(immstr == null) return self;
        else if(len.value < 0)
            throw new error("length cannot be less than zero");
        else if(len.value > sizeof(immstr))
            throw new error("length of: $len is greater than the string: ${sizeof(immstr)}");

        old_size : var = sizeof(data);

        if(data == null)
            data = new _int8[len.value];
        else
            realloc(data!!, sizeof(data) + len.value);

        memcopy(immstr!!, data!!, old_size, 0, len.value);
        return self;
    }

    def operator+(immstr : _int8[]?) : string {
        s := new string(data);
        return s.append(immstr ?: "null");
    }

    def to_lower() : string {
        str := new string();
        if(data != null) {
            str.data = copy(data!!, 0, sizeof(data));

            iter : var = 0;
            foreach(ch in data) {
                if('A' <= ch && ch <= 'Z')
                    str.data[iter] =  'a' + (ch - 'A');
                iter++;
            }
        }

        return str;
    }

    def operator+(obj : printable?) : string {
        s := new string(data);
        return s.append(obj?.to_string()?.data ?: "null");
    }

   def operator+(str : string?) : string {
       s := new string(data);
       return s.append(str?.data ?: "null");
   }

    override def to_string() : string? = new string(data);

    def operator==(str : _int8[]?) : bool {
        if(str == null || sizeof(data) != sizeof(str))
            return false;

        iter := 0;
        foreach(ch in str) {
            if(ch != data[iter++]) {
                return false;
            }
        }

        return true;
    }

    def operator==(str : string?) : bool {
        if(str == null || sizeof(data) != sizeof(str?.data))
            return false;

        iter := 0;
        foreach(ch in str?.data) {
            if(ch != data[iter++]) {
                return false;
            }
        }

        return true;
    }


    def operator!=(str : _int8[]?) := !operator==(str);
    def operator!=(str : string?) := !operator==(str);

    def operator=( immstr: _int8[]? )
    {
        if (immstr == null) data = null;
        else
            data = copy(immstr!!, 0, sizeof(immstr));
    }

    def at(pos : int) : char {
        if(pos.value >= sizeof(data))
            throw bounds_error(pos.value);
        return data[pos.value];
    }

    def operator[](pos: int) := at(pos);

    override def get_elements() := data;

    def to_char_array() : char_array?
    {
        if(data == null) return null;
        return new char_array(copy(data!!, 0, sizeof(data)));
    }


    def starts_with(prefix: string) : bool {
        if (prefix == null || (sizeof(prefix.data) > sizeof(data))) {
            return false;
        }

        for(i := 0; i < sizeof(prefix.data); i++)
        {
            if(data[i]!=prefix.data[i])
                return false;
        }
        return true;
    }

    def find(str: string) : bool {
        M := str.size();
        N := sizeof(data);

        /* A loop to slide pat[] one by one */
        for (i := 0; i <= N - M; i++) {
            j := 0;

            /* For current index i, check for
            pattern match */
            for (; j < M; j++)
                if (data[i + j]
                    != str.data[j])
                    break;

            if (j == M)
                return true;
        }

        return false;
    }

    def ends_with(postfix: string) : bool {
        if(sizeof(postfix.data) >= sizeof(data))
            return false;

        index := 0;
        for(i := sizeof(data) - sizeof(postfix.data); i < sizeof(data); i++){
            if(data[i] != postfix.data[index++])
                return false;
        }

        return true;
    }

    def operator+(num : _int8) : string {
        s := new string(data);
        return s.append(num);
    }

    def operator+(num : var) : string {
        return operator+(new double(num).to_string());
    }

    def operator+(num : _int16) : string {
        return operator+(new short(num).to_string());
    }

    def operator+(num : _int32) : string {
        return operator+(new int(num).to_string());
    }

    def operator+(num : _int64) : string {
        return operator+(new long(num).to_string());
    }

    def operator+(num : _uint8) : string {
        return operator+(num as _int8);
    }

    def operator+(num : _uint16) : string {
        return operator+(new ushort(num).to_string());
    }

    def operator+(num : _uint32) : string {
        return operator+(new uint(num).to_string());
    }

    def operator+(num : _uint64) : string {
        return operator+(new ulong(num).to_string());
    }

    def size() := sizeof(data);

    def operator+=( obj: printable? ) : string
    {
        return append(obj?.to_string()?.data ?: "null");
    }

    def operator+=( str: string ) := append(str.data!!);

    def operator+=( str: _int8[]? ) := append(str);

    def substring(start_pos: int, end_pos: int) : string {
        if((start_pos.value >= sizeof(data)) || (start_pos.value < 0))
            throw bounds_error(start_pos);
        if(end_pos.value < start_pos.value)
            throw new ill_arg_except(
                "end_pos: $end_pos cannot be less than the start_pos: $start_pos");


        str := new string();
        str.data = copy(data!!, start_pos.value, end_pos.value);
        return str;
    }

    private def bounds_error(pos : int) : bounds_except {
        return new bounds_except("Index out of bounds exception at: $pos with size of: ${sizeof(data)}");
    }

    override def hash() : int {
        const p := 31;
        const m := 1e9 + 9;
        hash_value := 0;
        p_pow : var = 1;
        foreach(c in data) {
            hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;
            p_pow = (p_pow * p) % m;
        }

        return hash_value;
    }
}
