mod platform.kernel;

import (
    std.io,
    std.io.fiber
)

class vm {
    static def get_frame_info() : stack_state {
        asm {
            int 0x35
            popObj2
            returnObj
            ret 0
        }
        return null;
    }

    static def get_stack_trace(info : stack_state) : string {
        asm {
            pushl {info}
            int 0x36
            popObj2
            returnObj
            ret 0
        }
        return null;
    }

    static def thread_create(daemon: var) : var {
        result: var;
        asm {
            movi adx, {_srt_thread_start}
            loadl ebx, {daemon}
            int 0x10
            smovr2 {result}, ebx
        }

        return result;
    }

    static def start_fiber(fib: fiber, t: thread, args: object[], main: (object[])(var)) : var {
        result: var;
        name := fib.name.get_data();
        threadid := -1; // -1 to unbind from thread

        if(t != null)
           threadid = t.get_native_handle();

        asm {
            pushl {args}
            pushl {fib}
            ipushl {threadid}
            ipushl {main}
            pushl {name}
            int 0x45
            smovr2 {result}, ebx
        }

        return result;
    }

    static def suspend_fiber(fib: fiber) : var {
        id := fib.id;
        result: var;

        asm {
            ipushl {id}
            int 0x46
            smovr2 {result}, ebx
        }

        return result;
    }

    static def unsuspend_fiber(fib: fiber) : var {
        id := fib.id;
        result: var;

        asm {
            ipushl {id}
            int 0x47
            smovr2 {result}, ebx
        }

        return result;
    }

    static def kill_fiber(fib: fiber) : var {
        id := fib.id;
        result: var;

        asm {
            ipushl {id}
            int 0x48
            smovr2 {result}, ebx
        }

        return result;
    }

    static def bind_fiber(fib: fiber, t: thread) : var {
        id := fib.id;
        threadid := -1; // -1 to unbind from thread

        if(t != null)
           threadid = t.get_native_handle();
        result: var;

        asm {
            ipushl {threadid}
            ipushl {id}
            int 0x49
            smovr2 {result}, ebx
        }

        return result;
    }

    static def get_bound_fibers(t: thread) : var {
        threadid := t.get_native_handle();
        result: var;

        asm {
            ipushl {threadid}
            int 0x4a
            smovr2 {result}, ebx
        }

        return result;
    }

    static def get_fiber_state(fib: fiber) : var {
        id := fib.id;
        result: var;

        asm {
            ipushl {id}
            int 0x4b
            smovr2 {result}, ebx
        }

        return result;
    }

    static def current_fiber() : fiber {
        result: fiber;

        asm {
            int 0x4c
            movl {result}
            popObj
        }

        return result;
    }

    static def suspend(t: thread) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, {id}
            int 0x12
            smovr2 {result}, cmt
        }

        return thread_result.at(result);
    }

    static def unsuspend(t: thread, wait: var) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, {id}
            loadl ebx, {wait}
            int 0x13
            smovr2 {result}, cmt
        }

        return thread_result.at(result);
    }

    static def get_os_time(tr : var) : var {
       result: var;
       asm {
          loadl ebx, {tr}
          int 0x2
          smovr2 {result}, bmr
       }

       return result;
    }

    static def thread_join(t: thread) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, {id}
            int 0xd
            smovr2 {result}, cmt
        }

        return thread_result.at(result);
    }

    static def kill(t: thread) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, {id}
            int 0xe
            smovr2 {result}, cmt
        }

        exit_thread(t, 1);
        return thread_result.at(result);
    }

    static def current_thread() : thread {
        asm {
            int 0x15
            popObj2
            returnObj
            ret 0
        }

        return null;
    }

    static def exit_thread(t: thread, code: var) {
        asm {
            movi ebx, 1
            movi egx, 0
            movi ecx, -1
            movi adx, 0
            movl 0
            movn {thread.exited}
            rmov adx, ebx

            movl 0
            movn {thread.started}
            rmov adx, egx

            loadl egx, {code}
            movl 0
            movn {thread.exit_code}
            rmov adx, egx

            movl 0
            movn {thread.native_handle}
            rmov adx, ecx
        }
    }

    static def thread_yield() {
        asm {
            int 0x1c
        }
    }

    static def thread_start(t: thread, args: object[]) : thread_result {
        id := t.get_native_handle();
        stack_size := t.get_stack_size();
        result: var;

        asm {
            loadl ebx, {stack_size}
            loadl adx, {id}
            pushl {args}
            pushl {t}
            int 0xc
            smovr2 {result}, cmt
        }

        if(result == 0) {
           while(!t.is_started()) {
               if(t.is_exited()) {
                   return result_thread_not_started;
               } else {
                  delay(2);
               }
           }
        }

        return thread_result.at(result);
    }

    static def set_thread_priority(t: thread, priority: var) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, {id}
            loadl egx, {priority}
            int 0x11
            smovr2 {result}, cmt
        }

        return thread_result.at(result);
    }

    static def set_thread(t: thread) {
        asm {
            pushl {t}
            int 0x17
        }
    }

    static def thread_args() : object[] {
        asm {
            int 0x16
            popObj2
            returnObj
            ret 0
        }

        return null;
    }

    static def hardware_concurrency() : var {
        result: var;

        asm {
            int 0x38
            smovr2 {result}, ebx
        }

        return result;
    }

    static def random_int() : var {
        result: var;

        asm {
           int 0x19
           smovr2 {result}, ebx
        }

        return result;
    }

    static def random_int(min: var, max : var) : var {
       result: var;

       asm {
          loadl ebx, {min}
          loadl egx, {max}
          int 0x3f
          smovr2 {result}, ebx
       }

       return result;
    }

    static def random_double() : var {
        result: var;

        asm {
           int 0x40
           smovr2 {result}, ebx
        }

        return result;
    }

    static def random_double(min: var, max : var) : var {
       result: var;

       asm {
          loadl ebx, {min}
          loadl egx, {max}
          int 0x41
          smovr2 {result}, ebx
       }

       return result;
    }

    static def random_seed(seed : var) {
       asm {
          loadl adx, {seed}
          int 0x42
       }
    }

}