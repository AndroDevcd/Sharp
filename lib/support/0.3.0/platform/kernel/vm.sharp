mod platform.kernel;

import (
    platform,
    std.io,
    std.io.fiber
)

class vm {

    static def exit(value: var) {
        asm {
            ipushl [value]
            int 0x1d
        }
    }

    private static def get_lib_path(name: string) : _int8[] {
        if(build.is_windows()) {
            name += ".dll";
        } else {
            name += ".so";
        }

        return new file(name).get_absolute_path().data!!;
    }

    static def load_library(name: string) {
        lib_name : _int8[] = get_lib_path(name);

        asm {
            pushl [lib_name]
            int 0x39
        }
    }

    static def free_library(name: string): int {
        lib_name : _int8[] = get_lib_path(name);
        result := 0;

        asm {
            pushl [lib_name]
            int 0x3a
            smovr2 [result], ebx
        }

        return result;
    }

    static def link_func(name: string, library: string): int {
        lib_name : _int8[] = get_lib_path(name);
        func_name := name.data;
        result : var = 0;
        asm {
            pushl [func_name]
            pushl [lib_name]
            int 0x3b
            smovr2 [result], ebx
        }

        return result;
    }

    static def get_frame_info() : stack_state? {
        asm {
            int 0x35
            popObj2
            returnObj
            ret 0
        }
        return null;
    }

    static def get_stack_trace(info : stack_state) : string? {
        asm {
            pushl [info]
            int 0x36
            popObj2
            returnObj
            ret 0
        }
        return null;
    }

    static def thread_create(daemon: var) : int {
        result: var;
        asm {
            movi adx, $std.io#__srt_global[_srt_thread_start]
            loadl ebx, [daemon]
            int 0x10
            smovr2 [result], ebx
        }

        return result;
    }

    static def start_fiber(fib: fiber, t: thread, args: object[]?, main: (object[]?)(var)) : int {
        result: var;
        name := fib.name.data;
        threadid : var = -1; // -1 to unbind from thread

        if(t != null)
           threadid = t.get_native_handle().value;

        asm {
            pushl [args]
            pushl [fib]
            ipushl [threadid]
            ipushl [main]
            pushl [name]
            int 0x45
            smovr2 [result], ebx
        }

        return result;
    }

    static def suspend_fiber(fib: fiber) : int {
        id := fib.id;
        result: var;

        asm {
            ipushl [id]
            int 0x46
            smovr2 [result], ebx
        }

        return result;
    }

    static def unsuspend_fiber(fib: fiber) : int {
        id := fib.id;
        result: var;

        asm {
            ipushl [id]
            int 0x47
            smovr2 [result], ebx
        }

        return result;
    }

    static def kill_fiber(fib: fiber) : int {
        id := fib.id;
        result: var;

        asm {
            ipushl [id]
            int 0x48
            smovr2 [result], ebx
        }

        return result;
    }

    static def bind_fiber(fib: fiber, t: thread?) : int {
        id := fib.id;
        threadid := -1; // -1 to unbind from thread

        if(t != null)
           threadid = t!!.get_native_handle();
        result: var;

        asm {
            ipushl [threadid]
            ipushl [id]
            int 0x49
            smovr2 [result], ebx
        }

        return result;
    }

    static def get_bound_fibers(t: thread?) : int {
        threadid : var;
        result: var;

        if(t != null)
            threadid = t!!.get_native_handle().value;

        asm {
            ipushl [threadid]
            int 0x4a
            smovr2 [result], ebx
        }

        return result;
    }

    static def get_fiber_state(fib: fiber) : int {
        id := fib.id;
        result: var;

        asm {
            ipushl [id]
            int 0x4b
            smovr2 [result], ebx
        }

        return result;
    }

    static def current_fiber() : fiber {
        result: fiber;

        asm {
            int 0x4c
            movl [result]
            popObj
        }

        return result;
    }

    static def suspend(t: thread) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, [id]
            int 0x12
            smovr2 [result], cmt
        }

        return thread_result.at(result);
    }

    static def unsuspend(t: thread, wait: var) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, [id]
            loadl ebx, [wait]
            int 0x13
            smovr2 [result], cmt
        }

        return thread_result.at(result);
    }

    static def get_os_time(tr : var) : long {
       result: var;
       asm {
          loadl ebx, [tr]
          int 0x2
          smovr2 [result], bmr
       }

       return result;
    }

    static def thread_join(t: thread) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, [id]
            int 0xd
            smovr2 [result], cmt
        }

        return thread_result.at(result);
    }

    static def kill(t: thread) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, [id]
            int 0xe
            smovr2 [result], cmt
        }

        t.set_finished(1);
        return thread_result.at(result);
    }

    static def current_thread() : thread {
        asm {
            int 0x15
            popObj2
            returnObj
            ret 0
        }

        excuse no_val: thread;
        return no_val;
    }

    static def thread_yield() {
        asm {
            int 0x1c
        }
    }

    static def thread_start(t: thread, args: object[]?) : thread_result {
        id : var = t.get_native_handle().value;
        stack_size : var = t.get_stack_size();
        result: var;

        asm {
            loadl ebx, [stack_size]
            loadl adx, [id]
            pushl [args]
            pushl [t]
            int 0xc
            smovr2 [result], cmt
        }

        if(result == 0) {
           while(!t.is_started()) {
               if(t.is_exited()) {
                   return result_thread_not_started;
               } else {
                  delay(0);
               }
           }
        }

        return thread_result.at(result);
    }

    static def set_thread_priority(t: thread, priority: var) : thread_result {
        id := t.get_native_handle();
        result: var;

        asm {
            loadl adx, [id]
            loadl egx, [priority]
            int 0x11
            smovr2 [result], cmt
        }

        return thread_result.at(result);
    }

    static def set_thread(t: thread) {
        asm {
            pushl [t]
            int 0x17
        }
    }

    static def thread_args() : object[] {
        asm {
            int 0x16
            popObj2
            returnObj
            ret 0
        }

        excuse no_val: object[];
        return no_val;
    }

    static def hardware_concurrency() : int {
        result: var;

        asm {
            int 0x38
            smovr2 [result], ebx
        }

        return result;
    }

    static def random_int() : int {
        result: var;

        asm {
           int 0x19
           smovr2 [result], ebx
        }

        return result;
    }

    static def random_int(min: var, max : var) : int {
       result: var;

       asm {
          loadl ebx, [min]
          loadl egx, [max]
          int 0x3f
          smovr2 [result], ebx
       }

       return result;
    }

    static def random_double() : double {
        result: var;

        asm {
           int 0x40
           smovr2 [result], ebx
        }

        return result;
    }

    static def random_double(min: var, max : var) : double {
       result: var;

       asm {
          loadl ebx, [min]
          loadl egx, [max]
          int 0x41
          smovr2 [result], ebx
       }

       return result;
    }

    static def time_in_nanoseconds() : long {
        now: var;

        asm
        {
            int 0xb
            smovr2 [now], bmr
        };

        return now;
    }

    static def lock_object(o: object) {
        asm {
            movl 0
            lock
        }
    }

    static def unlock_object(o: object) {
        asm {
            movl 0
            ulock
        }
    }

    static def delay(tm: long) {
       mills := tm.value;

       asm {
          loadl ebx, [mills]
          int 0x44
       }
    }

    static def random_seed(seed : int) {
        _seed := seed.value;
       asm {
          loadl adx, [_seed]
          int 0x42
       }
    }

}