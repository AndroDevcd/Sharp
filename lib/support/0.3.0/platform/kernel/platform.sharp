mod platform.kernel;

import (
    std.io,
    platform,
    std.io.coroutines
)

class platform
{

    private static main : (string[])(int);
    private static main2 : (string[])();
    private static main3 : ()();
    private static main4 : ()(int);

    static def tls_init() {}
    private static def static_init() {}

    private static def srt_init(args: object[]) : int {
        app_name := "${args[0] as _int8[]}";
        version := "${args[1] as _int8[]}";
        platform := "${args[2] as _int8[]}";
        os := "${args[3] as _int8[]}";

        build.app_name = app_name; // this needs to happen 2 times due to static_init<>
        build.version = version;
        build.platform = platform;
        build.os = os;

        static_init();
        tls_init();
        start_scheduler();

        build.app_name = app_name;
        build.version = version;
        build.platform = platform;
        build.os = os;

        main_thread := args[4] as thread;
        vm.set_thread(main_thread);

        priority := max_priority;
        thread_group.main_group.add(main_thread);

        set_seed((utc_mills() >> 4).to_int());

        asm {
            movg $thread_group
            movn $thread_group[main_group]

            pushObj

            movl [main_thread]
            movn $thread[parent_group]
            popObj

            movl [priority]
            pushObj

            movl [main_thread]
            movn $thread[priority]
            popObj
        }

        const min_args : var = 5;
        user_args := new string[sizeof(args) - min_args];
        iter : var = 0;

        for(i := min_args; i < sizeof(args); i++) {
            user_args[iter++] = new string(args[i] as _int8[]);
        }

        result := 0;
        when {
            main != 0 -> result = main(user_args);
            main2 != 0 -> main2(user_args);
            main3 != 0 -> main3();
            main4 != 0 -> result = main4();
        } // todo: look into main thread uncaught_exception_handler

        return result;
    }
}
