mod std;

import std.io;

class synced_list<t> : loopable<t> {
    private n_elements : var;
    private data : t[];
    private is_compact: var;
    private mut := new mutex();

    private static const default_capacity := 10;
    private static const min_capacity := 128;

    synced_list() {
        data = new t[default_capacity];
    }

    synced_list(starting_capacity: var) {
        data = new t[starting_capacity];
    }

    def set_compact(compact_array: var) {
        mut.acquire();
        is_compact = compact_array;
        mut.release();
    }

    def get_elements() : t[] {
        mut.acquire();
        if(n_elements == 0) return null;
        else return copy(data, 0, n_elements);
        mut.release();
    }

    def operator[](index: var): t {
        mut.acquire();
        if(index >= n_elements || index < 0)
            throw new bounds_except(out_of_bounds_msg(index));
        result := data[index];
        mut.release();
        return result;
    }

    def at(index: var): t {
        mut.acquire();
        if(index >= n_elements || index < 0)
            throw new bounds_except(out_of_bounds_msg(index));
        result := data[index];
        mut.release();
        return result;
    }

    def last(): t {
        return at(n_elements - 1);
    }

    def put(index: var, element: t) : t {
        mut.acquire();
        if (index >= n_elements || index < 0)
            throw new bounds_except(out_of_bounds_msg(index));

        old_val := data[index];
        data[index] = element;
        result := old_val;
        mut.release();
        return result;
    }

    private def expand() {
        if(is_compact) {
            realloc(data, sizeof(data) + min_capacity);
        } else
            realloc(data, sizeof(data) + (sizeof(data) >> 4) + min_capacity);
    }

    def clear() {
        mut.acquire();
        data = new t[default_capacity];
        n_elements = 0;
        mut.release();
    }

    def pop_last() : t {
        mut.acquire();
        item := last();
        pop_back();
        result := item;
        mut.release();
        return result;
    }

    def pop_first() : t {
        mut.acquire();
        item := data[0];
        remove_at(0);
        result := item;
        mut.release();
        return result;
    }

    def add_all(lst: list<t>) {
        mut.acquire();
        data = copy(lst.data, 0, lst.n_elements) as t[];
        n_elements = lst.n_elements;
        mut.release();
    }

    def add(element: t) {
        mut.acquire();
        if(n_elements >= sizeof(data))
            expand();
        data[n_elements++] = element;
        mut.release();
    }

    def indexof(element: t) : var {
        mut.acquire();
        for(i := 0; i < n_elements; i++) {
            if(element == data[i]) {
                mut.release();
                return i;
            }
        }

        mut.release();
        return -1;
    }

    def pop_back() {
        if(n_elements > 0) {
            no_val : t;
            data[--n_elements] = no_val;
        }
    }

    def size() : var {
        mut.acquire();
        result := n_elements;
        mut.release();
    }

    def empty() : var {
        mut.acquire();
        result := n_elements==0;
        mut.release();
    }

    def insert(index: var, element: t) {
        mut.acquire();
        if(index > n_elements || index < 0) {
           mut.release();
           throw new bounds_except(out_of_bounds_msg(index));
        }

        if(n_elements == 0) {
            add(element);
        } else {
           if(n_elements >= sizeof(data))
               expand();
           n_elements++;
            for(i := n_elements - 1; i > index; i--)
               data[i] = data[i-1];
            data[index] = element;
        }
        mut.release();
    }


    def remove(val: t) {
        mut.acquire();
        for(i := 0; i < n_elements; i++) {
            if(val == data[i]) {
                remove_at(i);
                mut.release();
                return;
            }
        }
        mut.release();
    }

    def remove(val: t, compare_fun: (t, t)(var)) {
        mut.acquire();
        for(i := 0; i < n_elements; i++) {
            if(compare_fun(val, data[i])) {
                remove_at(i);
                mut.release();
                return;
            }
        }
        mut.release();
    }

    def remove_at(index: var) {
        mut.acquire();
        if(index >= n_elements || index < 0) {
           mut.release();
           throw new bounds_except(out_of_bounds_msg(index));
        }

        num_moved := n_elements - index - 1;
        if (num_moved > 0)
            memcopy(data, data, index, index+1, n_elements);

        pop_back();
        mut.release();
    }

    def indexof(comparer: t, find_func: (t, t)(var)) : var {
        mut.acquire();
        for(i := 0; i < n_elements; i++) {
            if(find_func(data[i], comparer)) {
                mut.release();
                return i;
            }
        }

        mut.release();
        return -1;
    }

    def linear_sort(swap: (t, t)(var)) {
        mut.acquire();
        for(i := 0; i < n_elements; i++) {

            for (j := 0; j < n_elements; j++) {
                if((j + 1) < n_elements) {

                    if (swap(data[j], data[j+1])) {
                        tmp := data[j];
                        data[j] = data[j+1];
                        data[j+1] = tmp;
                    }
                }
            }
        }
        mut.release();
    }

    def find(comparer : t, find_func: (t, t)(var)) : t {
        mut.acquire();
        for(i := 0; i < n_elements; i++) {
            if(find_func(data[i], comparer)) {
                resut := data[i];
                mut.release();
                return result;
            }
        }

        no_val : t;
        mut.release();
        return no_val;
    }

    def replace(val: t, compare_fun: (t, t)(var)) : var {
        mut.acquire();
        for(i := 0; i < n_elements; i++) {
            if(compare_fun(val, data[i])) {
                data[i] = val;
                mut.release();
                return true;
            }
        }

        mut.release();
        return false;
    }

    def to_string() : string {
        mut.acquire();
        str := new string_builder();

        str += "[ ";
        for(i := 0; i < n_elements; i++) {
            str += data[i];

            if((i + 1) < n_elements) {
                str += ", ";
            }
        }

        str += " ]";
        result := str.to_string();
        mut.release();
        return result;
    }

    private def out_of_bounds_msg(index: var) : string {
        return "Index: $index, size: $n_elements";
    }
}