mod std.io.task;

import std.io;

class job_master {

	job_master() {
		long_term_pool = new thread_group("Long term jobs", min_priority);
		short_term_pool = new thread_group("Short term jobs", max_priority);
		job_queue = new synced_list<job>();
		running_jobs = new synced_list<job>();
	}

	def operator=(main: ()()) : job {
	    scheduled_job := create_job();
		scheduled_job = main;
		start_job(scheduled_job);
		return scheduled_job;
	}

	protected def create_job() := new job("job#${job.guid}");

	protected def create_job(name : string) := new job(name);

	protected def start_job(scheduled_job : job) {
	    lock(self) {
            if(!started) {
                start_scheduler();
                started = true;
            }
		}

		if(scheduled_job.delay_time)
			scheduled_job.delay_time = scheduled_job.delay_time + time.mills_time();

		if(scheduled_job.block_caller)
			execute_synchronous(scheduled_job);
		else {
			// the job scheduler will perform the start
			job_queue.add(scheduled_job);
		}
	}

	protected def add_job(scheduled_job : job) {
	   running_jobs.add(scheduled_job);
	}

	protected def cleanup_job(scheduled_job : job) {
		scheduled_job.deferred_obj = null;
		scheduled_job.host = null;
		scheduled_job.host = null;
		scheduled_job.next_task = null;
		scheduled_job.args = null;
		scheduled_job.name = null;
		job_queue.remove(scheduled_job, { it, it2 -> return it.id == it2.id; });
		running_jobs.remove(scheduled_job, { it, it2 -> return it.id == it2.id; });
	}

	protected def cancel_jobs_by_name(name: string) {
	   lock(job_queue) {
           for(i := 0; i < job_queue.size(); i++) {
              if(job_queue.at(i).name == name) {
                 job_queue.remove_at(i);
                 i = 0;
              }
           }

           foreach(schdj in running_jobs) {
               if(schdj.name == name) {
                  schdj.cancel();
		          running_jobs.remove(schdj, { it, it2 -> return it.id == it2.id; });
               }
           }
       }
	}

	protected running_jobs : synced_list<job>;
	protected job_queue : synced_list<job>;
	protected long_term_pool : thread_group;
	protected short_term_pool : thread_group;
	protected started: var;
}
