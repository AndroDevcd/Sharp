mod platform.kernel;

import std.io;
import std.io.coroutines;
import platform;

class platform
{
    private static main : (string[])(var);
    private static main2 : (string[])();
    private static main3 : ()();
    private static main4 : ()(var);

    static def tls_init() {}
    private static def static_init() {}

    static def exit(value: var) {
        asm {
            ipushl {value}
            int 0x1d
        }
    }

    private static def get_lib_path(name: string) : _int8[] {
        if(build.is_windows()) {
            name += ".dll";
        } else {
            name += ".so";
        }

        return new file(name).get_absolute_path().get_data();
    }

    static def load_library(name: string) {
        lib_name : _int8[] = get_lib_path(name);
        asm {
            pushl {lib_name}
            int 0x39
        }
    }

    static def free_library(name: string): var {
        lib_name : _int8[] = get_lib_path(name);
        result := 0;
        asm {
            pushl {lib_name}
            int 0x3a
            smovr2 {result}, ebx
        }

        return result;
    }

    static def link_func(name: string, library: string): var {
        lib_name : _int8[] = get_lib_path(name);
        func_name := name.get_data();
        result := 0;
        asm {
            pushl {func_name}
            pushl {lib_name}
            int 0x3b
            smovr2 {result}, ebx
        }

        return result;
    }

    private static def srt_init(args: object[]) : var {
//          asm {
//            nop
//            int 0x0
//            movi ebx, 1
//            newVarArray ebx, 1
//            movl 0
//            popObj
//            newClass 1
//            movl 0
//            popObj
//            cast ebx
//            mov8 ebx, ebx
//            mov16 ebx, ebx
//            mov32 ebx, ebx
//            mov64 ebx, ebx
//            movu8 ebx, ebx
//            movu16 ebx, ebx
//            movu32 ebx, ebx
//            movu64 ebx, ebx
//            rstore ebx
//            pop
//            add ebx, ebx, ebx
//            sub ebx, ebx, ebx
//            mul ebx, ebx, ebx
//            div ebx, ebx, ebx
//            mod ebx, ebx, ebx
//
//            iadd ebx, 10
//            isub ebx, 10
//            idiv ebx, 10
//            imod ebx, 10
//            inc ebx
//            dec ebx
//            movr ebx, egx
//            movi adx, @skipme
//            movi cmt, 1
//            brh
//
//            .skipme:
//               nop
//
//            movi adx, @skipme2
//            ife
//
//            .skipme2:
//               nop
//
//            lt egx, ebx
//            gt egx, ebx
//            le egx, ebx
//            ge egx, ebx
//            movl 0
//            movsl 0
//            sizeof ebx
////            put ebx
////            putc egx
//            movi ebx, '\n'
////            putc ebx
//            movi ebx, 1
//            newVarArray ebx, 1
//            movl 0
//            popObj
//            movi ebx, 0
//            checklen ebx
//            jmp @brhme
//
//            .brhme:
//              nop
//
//            loadpc ebx
//            movl 0
//            pushObj
//            popObj
//
//            movsl 5
//            del
//
//            //call {foo}
//            newClass 30 // thread
//            movl 0
//            popObj
//            movn 0
//            pushObj
//            pop
//            movi ebx, 1000
//            sleep ebx
//
//            te ebx, egx
//            tne ebx, egx
//            movl 0
//            nop
//            nop
//            nop
//            nop
//            nop
//            nop
//            nop
//            nop
//            nop
//            nop
//            nop
//            nop
//            nop
//            nop
//            lock
//            ulock
//            movl 0
//            movi ebx, 0
//            movnd ebx
//            movi ebx, 1
//            newObjArray ebx
//            pop
//            not ebx, ebx
//            skip 1
//            nop
//            nop
//            nop
//            loadVal  ebx
//            shr ebx, ebx, ebx
//            shl ebx, ebx, ebx
//            skipife ebx, 1
//            nop
//            nop
//            nop
//            and ebx, ebx
//            uand ebx, ebx
//            movl 0
//            checknull ebx
//            movi ebx, 1
//            newClassArray ebx, 1
//            pop
//            newString 1
//            pop
//            addl ebx, 1
//            subl ebx, 1
//            modl ebx, 1
//            iaddl 1, 1
//            isubl 1, 1
//            imodl 1, 1
//            loadl ebx, 1
//            movl 0
//            movi ebx, 2
//            newVarArray ebx, 1
//            popObj
//            movi ebx, 0
//            iaload ebx, ebx
//            smovr ebx, 0
//            andl ebx, 0
//            orl ebx, 0
//            istore 10
//            pop
//            smovr2 10, ebx
//            istorel 1, 1
//            pop
//            tlsMovl 0
//            movl 0
//            movi ebx, 2
//            newVarArray ebx, 1
//            popObj
//            varCast 1, 1
//          }
//
//            asm {
//                movl 0
//                movi ebx, 2
//                newVarArray ebx, 1
//                popObj
//                movi adx, 0
//                iaload ebx, adx
//            }

//          for(;;) {
//             std.io.fiber#delay(1);
//          }
//
//          return 0;
        build.app_name = "${args[0] as _int8[]}";
        build.version = "${args[1] as _int8[]}";
        build.platform = "${args[2] as _int8[]}";
        build.os = "${args[3] as _int8[]}";

        static_init();
        tls_init();
        start_scheduler();

        main_thread := args[4] as thread;
        vm.set_thread(main_thread);

        priority := max_priority;
        thread_group.main_group.add(main_thread);

        asm {
            movg {thread_group}
            movn {thread_group.main_group}
            pushObj

            movl {main_thread}
            movn {thread.parent_group}
            popObj

            movl {priority}
            pushObj

            movl {main_thread}
            movn {thread.priority}
            popObj
        }

        const min_args := 5;
        user_args := new string[sizeof(args) - min_args];
        iter := 0;

        for(i := min_args; i < sizeof(args); i++) {
            user_args[iter++] = new string(args[i] as _int8[]);
        }

        result := 0;
        when {
            main != 0 -> result = main(user_args);
            main2 != 0 -> main2(user_args);
            main3 != 0 -> main3();
            main4 != 0 -> result = main4();
        }

        return result;
    }
}
