mod frontend.parser;

import frontend.tokenizer;

/**
 * Created by BraxtonN on 6/14/2018.
 */
class ast {
    public line: var;
    public col: var;
    type: ast_type;
    private tokens: list<token>;
    private children: list<ast>;

    public ast()
    {
        self->tokens = new list<token>();
        self->children = new list<ast>();
    }

    public ast(type: ast_type, line: var, col: var)
    {
        self->type = type;
        self->line = line;
        self->col = col;
        self->tokens = new list<token>();
        self->children = new list<ast>();
    }

    public def add(ast: ast) {
        children.add(ast);
    }

    public def add(token: token) {
        tokens.add(token);
    }

    public def token_at(pos: var) : token {
        return tokens.at(pos);
    }

    public def token_size() : var {
        return tokens.size();
    }

    public def children_size() : var {
        return children.size();
    }

    public def has_token(type: token_type) : var {
        foreach(tok in tokens) {
            if(tok.get_type() == type)
                return true;
        }

        return false;
    }

    public def clear() {
        children.clear();
        tokens.clear();
    }

    public def has_child(type: ast_type) : var {
        foreach(child in children) {
            if(child.type == type)
                return true;
        }

        return false;
    }

    public def get_child(pos: var) : ast {
        return children.at(pos);
    }

    public def get_child(type: ast_type) : ast {
        foreach(child in children) {
            if(child.type == type)
                return child;
        }
        return null;
    }

    public def last() : ast {
        return children.last();
    }

    public def last_token() : token {
        return tokens.last();
    }

    public def encapsulate(type: ast_type) : ast {
        encap := new ast(type, line, col);

        encap.children.add_all(children);
        encap.tokens.add_all(tokens);

        children.clear();
        tokens.clear();
        children.add(encap);
        return encap;
    }

    private def add_tabs(sb: string_builder) {
        for(i := 0; i < recurs; i++)
            sb+='\t';
    }

    thread_local recurs := 0;
    public def to_string(sb: string_builder) {
        add_tabs(sb);
        sb += "ast: " + type + " ;" + line + "," + col + "\n";

        recurs++;
        add_tabs(sb);
        sb += "tokens:\n";
        foreach(tok in tokens) {
            add_tabs(sb);
            if(tok != null)
                sb += "" + tok + "\n";
            else
                sb += "null\n";
        }

        add_tabs(sb);
        
        sb += "children: (" + children.size() + ")\n";
        foreach(child in children) {
            add_tabs(sb);

            if(child != null)
                child.to_string(sb);
            else
                sb += "null\n";
        }

        sb += '\n';
        recurs--;
    }

    public def copy(ast: ast) {
        line = ast.line;
        col = ast.col;
        type = ast.type;

        children.add_all(ast.children);
        tokens.add_all(ast.tokens);
    }

    public def fast_copy(ast: ast) {
        children.clear();
        tokens.clear();

        line = ast.line;
        col = ast.col;
        type = ast.type;
        children = ast.children;
        tokens = ast.tokens;
    }

    public def pop_token() {
        tokens.pop_back();
    }

    public def pop_child() {
        children.pop_back();
    }

    public def get_type() : ast_type {
        return type;
    }

    public def set_type(type: ast_type) {
        self->type = type;
    }
}

enum ast_type {
    ast_class_decl,
    ast_generic_class_decl,
    ast_generic_interface_decl,
    ast_obfuscate_decl,
    ast_interface_decl,
    ast_import_decl,
    ast_mutate_decl,
    ast_module_decl,
    ast_method_decl,
    ast_enum_decl,
    ast_delegate_post_decl,
    ast_delegate_decl,
    ast_constructor_decl,
    ast_label_decl,
    ast_operator_decl,
    ast_variable_decl,
    ast_switch_declarator,
    ast_value,
    ast_name,
    ast_getter,
    ast_setter,
    ast_value_list,
    ast_utype_arg_list,
    ast_utype_arg_list_opt,
    ast_reference_identifier_list,
    ast_reference_pointer_list,
    ast_generic_utype_list,
    ast_utype_list,
    ast_identifier_list,
    ast_enum_identifier_list,
    ast_vector_array,
    ast_utype_arg,
    ast_utype_arg_opt,
    ast_expression,
    ast_array_expression,
    ast_primary_expression,
    ast_dotnotation_call_expr,
    ast_utype,
    ast_block,
    ast_switch_block,
    ast_finally_block,
    ast_assembly_block,
    ast_catch_clause,
    ast_method_return_type,
    ast_return_stmnt,
    ast_statement,
    ast_if_statement,
    ast_switch_statement,
    ast_elseif_statement,
    ast_else_statement,
    ast_lock_statement,
    ast_trycatch_statement,
    ast_throw_statement,
    ast_continue_statement,
    ast_break_statement,
    ast_goto_statement,
    ast_while_statement,
    ast_do_while_statement,
    ast_assembly_statement,
    ast_for_statement,
    ast_for_expression_cond,
    ast_for_expression_iter,
    ast_foreach_statement,
    ast_type_identifier,
    ast_enum_identifier,
    ast_func_pointer,
    ast_reference_pointer,
    ast_modulename,
    ast_literal,
    ast_import_module,
    ast_primary_constr,
    ast_constructor_arg,
    ast_base_constr_args,
    ast_access_type,
    ast_obfuscate_block,
    ast_obfuscate_element,

    /**
     * Encapsulated ast's to make processing expressions easier
     */
    ast_literal_e,
    ast_utype_class_e,
    ast_dot_not_e,
    ast_self_e,
    ast_base_e,
    ast_null_e,
    ast_new_e,
    ast_not_e,
    ast_post_inc_e,
    ast_arry_e,
    ast_dot_fn_e,
    ast_cast_e,
    ast_pre_inc_e,
    ast_paren_e,
    ast_vect_e,
    ast_add_e,
    ast_mult_e,
    ast_shift_e,
    ast_less_e,
    ast_equal_e,
    ast_and_e,
    ast_ques_e,
    ast_assign_e,
    ast_sizeof_e,
    ast_free_e,

    ast_none
};
