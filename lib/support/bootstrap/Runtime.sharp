mod app;

import std;
import std.io;
import std.kernel;

/**                          
* Created by bknun on 6/5/2018            
* Description:                             
*/
public class Runtime {

    private static string programName = "sharpc";
    private static string programVers = "0.3.0";

    public static def bootstrap(string[] args) : var {
        if(args == null) {
            help();
            return 1;
        }

//        ErrorManager.initErrors();
        ArrayList<string> files = new ArrayList<string>();
        for(var i = 0; i < sizeof(args); i++) {

            parseArg:
            string arg = args[i];
            if(arg == "-a"){
                Options.aggressiveErrors = true;
            }
            else if(arg == "-c"){
                Options.compile = true;
            }
            else if(arg == "-o"){
                if(i+1 >= sizeof(args))
                    error("output file required after option `-o`");
                else
                    Options.out = args[++i];
            }
            else if(arg == "-L"){
                if(i+1 >= sizeof(args))
                    error("library directory required after option `-L`");
                else
                    Options.libraries.add(args[++i]);
            }
            else if(arg == "-V"){
                printVersion();
                exit();
            }
            else if(arg == "-O" || arg == "-O1"){
                Options.optimizeLevel = Optimization.BASIC;
            }
            else if(arg == "-O2"){
                Options.optimizeLevel = Optimization.HIGH_PERFORMANCE;
            }
            else if(arg == "-h" || arg == "-?"){
                help();
                exit();
            }
            else if(arg == "--hw"){
                helpWarning();
                exit();
            }
            else if(arg == "-R" || arg == "-release"){
                Options.optimizeLevel = Optimization.HIGH_PERFORMANCE;
                Options.debug = false;
                Options.strip = true;
            }
            else if(arg == "-s"){
                Options.strip = true;
                Options.debug = false;
            }
            else if(arg == "-magic"){
                Options.magic = true;
            }
            else if(arg == "-dbg") {
                Options.debugMode = true;
            }
            else if(arg == "-showversion"){
                printVersion();
                println();
            }
            else if(arg == "-target"){
                if(i+1 >= sizeof(args))
                    error("file version required after option `-target`");
                else {
                    string target = args[++i];
                    if(integerString(target)) {
                        Options.target = string.parseInt(target);
                        checkTarget();
                    } else {
                        if(string.toLower(target) == "alpha") {
                            Options.target = Platform.ALPHA;
                        }
                        else {
                            error("unknown platform target " + target);
                        }
                    }
                }
            }
            else if(arg == "-w"){
                Options.warnings = false;
            }
            else if(arg == "-waccess"){
                warningOptions[__WACCESS] = false;
            }
            else if(arg == "-wambig"){
                warningOptions[__WAMBIG] = false;
            }
            else if(arg == "-wdecl"){
                warningOptions[__WDECL] = false;
            }
            else if(arg == "-wmain"){
                warningOptions[__WMAIN] = false;
            }
            else if(arg == "-wcast"){
                warningOptions[__WCAST] = false;
            }
            else if(arg == "-winit"){
                warningOptions[__WINIT] = false;
            }
            else if(arg == "-v"){
                if(i+1 >= sizeof(args))
                    error("file version required after option `-v`");
                else
                    Options.version = args[++i];
            }
            else if(arg == "-werror"){
                Options.werrors = true;
                Options.warnings = true;
            }
            else if(arg == "-errlmt") {
                string lmt = args[++i];

                if(integerString(lmt)) {
                    Options.maxErrors = string.parseInt(lmt);
            
                    if(Options.maxErrors > 100000) {
                        error("cannot set the max errors allowed higher than (100,000) - " + lmt);
                    } else if(Options.maxErrors <= 0) {
                        error("cannot have an error limit of 0 ");
                    }
                }
                else {
                    error("invalid error limit set " + lmt);
                }
            }
            else if(arg.startsWith("-asmd")){
                Options.asmDump = true;

                if(arg.startsWith("-asmd:")) {
                    if(arg.size() > 6 && arg.size() <= 9) {
                        var[] arry = arg.substring(7).getData();
                        for(var j = 0; j < sizeof(arry); j++)
                        {
                            switch(arry[j]) {
                                case 'd':
                                    asmDumpOptions[ASM_DEMANGLE] = true;
                                    break;
                                case 's':
                                    asmDumpOptions[ASM_SYNTAX] = true;
                                    break;
                                case 'i':
                                    asmDumpOptions[ASM_DEBUG_INFO] = true;
                                    break;
                                default:
                                    error("invalid option `" + arg + "`, try bootstrap -h");
                                    break;
                            }
                        }
                    } else {
                        error("invalid option `" + arg + "`, try bootstrap -h");
                    }
                }
            }
            else if(arg.at(0) == '-'){
                error("invalid option `" + arg + "`, try bootstrap -h");
            }
            else {
                // add the source files
                do {
                    arg = args[i];
                    if(arg.at(0) == '-')
                        goto parseArg;

                    if(!contains(files, arg))
                        files.add(arg);
                    i++;
                }while(i<sizeof(args));
                break;
            }
        }

        if(files.size() == 0){
            help();
            return 1;
        }

        string path = "";
        if(Manifest.isWindows()) {
            path = "C:\\Sharp\\include";
        } else {
            path = "/usr/include/sharp/";
        }

        File stlFiles = new File(path);
        string[] supportFiles;

        try {
            supportFiles = stlFiles.list();
            foreach(string file : supportFiles) {
                files.add(file);
            }
        } catch(IOException io) {
            /* support files not found */
            println("warning: could not find support library files in path `" + path + "`, do you have them installed?");
        }


        for(var i = 0; i < Options.libraries.size(); i++) {
            stlFiles.updatePath(Options.libraries.get(i));

            try {
                supportFiles = stlFiles.list();
            } catch(IOException io) {
                /* support files not found */
                error("could not access library files in path `" + path + "`");
            }

            foreach(string file : supportFiles) {
                files.add(file);
            }
        }

        File file = new File("no_file");
        for(var i = 0; i < files.size(); i++) {
            file.updatePath(files.get(i));
            if(!(file.exists()))
                error("file `" + files.get(i) + "` doesnt exist!");

            if(!files.get(i).endsWith(".sharp"))
                error("file `" + files.get(i) + "` is not a sharp file!");
        }

        exec_runtime(files);
        return 0;
    }

    static def contains(ArrayList<string> files, string file) : var {
        string[] lst = files.data();
        var size = files.size();
        for(var i = 0; i < size; i++) {
            if(lst[i] == file)
                return true;
        }

        return false;
    }

    static def exec_runtime(ArrayList<string> files) {

        File testFile = new File(files.get(0));
//
        IOStream istream = new IOStream(testFile, IOStream.READ);
        string tokens = istream.getData();
//
//        istream.close();
        Tokenizer tokenizer = new Tokenizer(tokens, files.get(0));
        Parser parser = new Parser(tokenizer);
        parser.getErrors().printErrors();
    }


    private static def integerString(string str) : var {
        var[] chs = str.getData();
        foreach(var c : chs) {
            if(!char.isDigit(c))
                return false;
        }
        return true;
    }

    private static def checkTarget() {
        switch(Options.target) {
            case Platform.ALPHA:
                return;
            default:
                error("invalid platform target `" + Options.target + "`");
                break;
        }
    }

    private static def error(string message) {
        println("sharpc:  error: " + message);
        exit();
    }

    private static def printVersion() {
        print(programName + " " + programVers);
    }

    private static def help() {
        println("Usage: sharpc " + "{OPTIONS} SOURCE FILE(S)");
        println("Source file must have a .sharp extion to be compiled.\n");
        println("[-options]\n\n    -V                print compiler version and exit");
        println(              "    -showversion      print compiler version and continue"               );
        println(              "    -o<file>          set the output object file"                        );
        println(              "    -c                compile only and do not generate exe"              );
        println(              "    -a                enable aggressive error reporting"                 );
        println(              "    -s                strip debugging info"                              );
        println(              "    -O -O1            optimize code level 1"                             );
        println(              "    -O2               optimize code level 2"                             );
        println(              "    -L<path>          library directory path"                            );
        println(              "    -w                disable all warnings"                              );
        println(              "    -errlmt<count>    set max errors the compiler allows before quitting");
        println(              "    -v<version>       set the application version"                       );
        println(              "    -unsafe -u        allow unsafe code"                                 );
        println(              "    -objdmp           create dump file for generated assembly"           );
        println(              "    -target           target the specified platform of sharp to run on"  );
        println(              "    -release -r       generate a release build exe"                      );
        println(              "    --asmd            display assembly dump message for output options"  );
        println(              "    --hw              display help message for warning options"          );
        println(              "    --h -?            display this help message"                         );
    }

    private static def helpWarning() {
        println( "Usage: sharpc {OPTIONS} SOURCE FILE(S)");
        println( "Source file must have a .sharp extion to be compiled.\n");
        println( "Please note that not all warnings will be able to be disabled individually.\n");
        println( "[-options]\n\n    -w                disable all warnings"                                     );
        println(               "    -winit            disable class initialization warnings"                    );
        println(               "    -waccess          disable access modifier warnings (public, static, etc.)"  );
        println(               "    -wambig           disable ambiguous symbol warnings"                        );
        println(               "    -wdecl            disable object declaration warnings"                      );
        println(               "    -wmain            disable multiple main method warnings"                    );
        println(               "    -wcast            disable type cast warnings"                               );
        println(               "    -werror           enable warnings as errors"                                );
        println(               "    --hw              display this help message"                                );
    }

    private static def helpAssemblyDump() {
        println( "Usage: sharpc {OPTIONS} SOURCE FILE(S)");
        println( "Source file must have a .sharp extion to be compiled.\n");
        println( "Please note that default output format will be printed as-is with no debugging information, syntax reformatting, or address information.\n");
        println( "All compiler options for `-asmd` can be chained together i.e. (-asmd:is, -asmd:dsi, etc.)\n");
        println( "[-options]\n\n    -asmd             dump raw generated assembly into file (outputted w/default output setting)"   );
        println(               "    -asmd:d           de-mangle source to show names"                                               );
        println(               "    -asmd:s           reformat code to show sharp assembly syntax"                                  );
        println(               "    -asmd:i           display debug information i.e (line numbers, file names, etc.)"               );
        println(               "    --asmd            display this help message"                                                    );
    }
}