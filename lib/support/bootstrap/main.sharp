mod main;

import std.io;
import std.io.*;
import platform;
import frontend.*;
import platform.kernel;

private program_name : string = "sharpc";
private program_vers : string = "0.3.0";
private files := new list<string>();

def main(args: string[]) : var {
    if(args == null) {
        help();
        return 1;
    }

    for(i := 0; i < sizeof(args); i++) {

        parse_arg:
        arg := args[i];
        if(arg == "-a"){
            options.aggressive_errors = true;
        }
        else if(arg == "-c"){
            options.compile = true;
        }
        else if(arg == "-o"){
            if(i+1 >= sizeof(args))
                error("output file required after option `-o`");
            else
                options.out = args[++i];
        }
        else if(arg == "-L"){
            if((i+1) >= sizeof(args))
                error("library directory required after option `-L`");
            else {
                library_dir := new file(args[++i]);
                if(!library_dir.exists()) {
                   error("library path: library_dir dosen't exist!");
                }

                if(!library_dir.is_directory()) {
                   error("library path: library_dir is not a directory");
                }

                options.libraries.add(library_dir.get_absolute_path());
            }
        }
        else if(arg == "-V"){
            print_version();
            exit();
        }
        else if(arg == "-O" || arg == "-O1"){
            options.optimize_level = optimization_level.basic;
        }
        else if(arg == "-O2"){
            options.optimize_level = optimization_level.high_performance;
        }
        else if(arg == "--h" || arg == "-?"){
            help();
            exit();
        }
        else if(arg == "--hw"){
            help_warning();
            exit();
        }
        else if(arg == "-R" || arg == "-release"){
            options.optimize_level = optimization_level.high_performance;
            options.debug = false;
            options.strip = true;
        }
        else if(arg == "-s"){
            options.strip = true;
            options.debug = false;
        }
        else if(arg == "-magic"){
            options.magic = true;
        }
        else if(arg == "-dbg") {
            options.debug_mode = true;
        }
        else if(arg == "-showvers" || arg == "-showversion"){
            print_version();
            println();
        }
        else if(arg == "-target"){
            if(i+1 >= sizeof(args))
                error("file version required after option `$arg`");
            else {
                target := args[++i];
                if(is_number(target)) {
                    options.target = int.parse(target);
                    check_target();
                } else {
                    if(target.to_lower() == "alpha") {
                        options.target = main#platform.alpha;
                    }
                    else {
                        error("unknown platform target $target");
                    }
                }
            }
        }
        else if(arg == "-w"){
            options.warnings = false;
        }
        else if(arg == "-waccess"){
            warning_options[__w_access] = false;
        }
        else if(arg == "-wambig"){
            warning_options[__w_ambig] = false;
        }
        else if(arg == "-wdecl"){
            warning_options[__w_decl] = false;
        }
        else if(arg == "-wmain"){
            warning_options[__w_main] = false;
        }
        else if(arg == "-wcast"){
            warning_options[__w_cast] = false;
        }
        else if(arg == "-winit"){
            warning_options[__w_init] = false;
        }
        else if(arg == "-p"){
            options.compile_mode = compilation_mode.project_mode;
        }
        else if(arg == "-run"){
            options.run_source = true;
        }
        else if(arg == "-g" || arg == "-green"){
            options.green_mode = true;
        }
        else if(arg == "--new-project"){
            if(i+1 >= sizeof(args))
                error("project directory required after option `$arg`");
            else {
                options.new_project_dir = args[++i];
            }
        }
        else if(arg == "-v"){
            if(i+1 >= sizeof(args))
                error("file version required after option `-v`");
            else
                options.version = args[++i];
        }
        else if(arg == "-ignore"){
            if(i+1 >= sizeof(args))
                error("file path required after option `$arg`");
            else {
                ignored_file := new file(args[++i]);
                if(!ignored_file.exists()) {
                   error("ignored file: $ignored_file dosen't exist!");
                }

                if(ignored_file.is_directory()) {
                   error("ignored file: $ignored_file is a directory, try `-ignoredir` instead");
                }

                options.ignored_files.add(ignored_file.get_absolute_path());
            }
        }
        else if(arg == "-ignoredir"){
            if(i+1 >= sizeof(args))
                error("directory path required after option `$arg`");
            else {
                ignored_dir := new file(args[++i]);
                if(!ignored_dir.exists()) {
                   error("ignored directory: $ignored_dir dosen't exist!");
                }

                if(!ignored_dir.is_directory()) {
                   error("ignored directory: $ignored_dir is a file, try `-ignore` instead");
                }

                options.ignored_directories.add(ignored_dir.get_absolute_path());
            }
        }
        else if(arg == "-P"){
            if(i+1 >= sizeof(args))
                error("project path required after option `$arg`");
            else {
                proj_dir := new file(args[++i]);
                if(!proj_dir.exists()) {
                   error("project directory: $proj_dir dosen't exist!");
                }

                if(!proj_dir.is_directory()) {
                   error("project directory: $proj_dir was found to be a file");
                }

                options.compile_mode = compilation_mode.project_mode;
                options.project_dir = proj_dir.get_absolute_path();
            }
        }
        else if(arg == "-werror"){
            options.werrors = true;
            options.warnings = true;
        }
        else if(arg == "-errlmt") {
            lmt := args[++i];

            if(is_number(lmt)) {
                options.max_errors = int.parse(lmt);

                if(options.max_errors > 100000) {
                    error("cannot set the max errors allowed higher than (100,000) - $lmt");
                } else if(options.max_errors <= 0) {
                    error("cannot have an error limit of 0 ");
                }
            }
            else {
                error("invalid error limit set $lmt");
            }
        }
        else if(arg.at(0) == '-'){
            error("invalid option `" + arg + "`, try $program_name --h");
        }
        else {
            // add the source files
            do {
                arg = args[i];
                if(arg.at(0) == '-')
                    goto parse_arg;

                if(!contains(files, arg))
                    files.add(arg);
                i++;
            }while(i<sizeof(args));
            break;
        }
    }

    if(options.new_project_dir != "") {
       create_project();
    }

    if(files.size() == 0 && options.compile_mode == compilation_mode.file_mode){
        help();
        return 1;
    }

    if(options.compile_mode == compilation_mode.project_mode) {
        // TODO: process settings.json file
        proj_dir : file;
        if(options.project_dir != "") {
            proj_dir = new file(options.project_dir);
        } else {
            proj_dir = new file(file.current_directory());
        }

        try {
           foreach(file in proj_dir.list()) {
               if(file.ends_with(".sharp"))
                  files.add(file);
           }
        } catch(io_exception) {
            /* support files not found */
            error("could not access project directory files in: $proj_dir");
        }
    }/* else {
        add_library_files(program_vers);
    }*/

    fp := new file("no_file");
    for(i := 0; i < files.size(); i++) {
        fp.update_path(files[i]);

        if(!(fp.exists()))
            error("file `${files.at(i)}` doesnt exist!");

        if(!files[i].ends_with(".sharp"))
            error("file `${files.at(i)}` is not a sharp file!");
        files[i] = fp.get_absolute_path();
    }

    // remove duplicate files
    for(i := 0; i < files.size(); i++) {

        if(count(files, files[i]) > 1) {
           files.remove_at(i); i--;
        }
    }

    remove_ignored_files(files);
    exec_runtime(files);
    return 0;
}

def add_library_files(version_num: string) {
    is_supported := false;
    foreach(vers in supported_versions) {
       if(version_num == vers) {
          is_supported = true;
          break;
       }
    }

    if(!is_supported) {
        err_msg : string = "Library api version: $version_num is not supported!";
        err_msg += " Supported versions are: {";

        pos := 0, size = sizeof(supported_versions);
        foreach(vers in supported_versions) {
           err_msg += " $vers";

           if((pos + 1) < size) {
              err_msg += ",";
           } else {
              err_msg += " ";
           }

           pos++;
        }

        err_msg += "}";

        error(err_msg);
    }

    path : string = "";
    if(build.is_windows()) {
        path = "C:\\Program Files\\Sharp\\include\\$version_num";
    } else {
        path = "/usr/include/sharp/$version_num";
    }

    stl_files := new file(path);
    support_files:= new list<string>();

    try {
        foreach(file in stl_files.list()) {
            if(file.ends_with(".sharp"))
              files.add(file);
        }
    } catch(io_exception) {
        /* support files not found */
        error("could not find support library files in path `$path`, did you correctly install the target api?");
    }


    for(i := 0; i < options.libraries.size(); i++) {
        stl_files.update_path(options.libraries.at(i));

        try {
            foreach(file in stl_files.list()) {
               if(file.ends_with(".sharp"))
                  files.add(file);
            }
        } catch(io_exception) {
            /* support files not found */
            error("could not access library files in path `$path`");
        }

    }
}

def contains(files: list<string>, file: string) : var {

    foreach(f in files) {
        if(f == file)
            return true;
    }

    return false;
}

def count(files: list<string>, file: string) : var {
    amount := 0;
    foreach(f in files) {
        if(f == file)
            amount++;
    }

    return amount;
}

def in_ignored_folder(fullpath: string) : var {
   foreach(path in options.ignored_directories) {
      if(fullpath.starts_with(path))
        return true;
   }

   return false;
}

def is_ignored_file(fullpath: string) : var {
   foreach(path in options.ignored_files) {
      if(fullpath == path)
        return true;
   }

   return false;
}

def remove_ignored_files(files: list<string>) {
    for(i := 0; i < files.size(); i++) {
      if(in_ignored_folder(files[i]) || is_ignored_file(files[i])) {
         files.remove_at(i); i--;
      }
    }
}

/**
* We dont want to max out the CPU if green mode is set to true
* So we cut the maximum available threads in half. While this will consume less power,
* it will result in longer build times overall.
*/
def throttle_max_threads() {
    threads := vm.hardware_concurrency() * 2;
    threads -= 4;

    if(threads > 3)
       threads /= 2;
    set_thread_max(threads);
}

def exec_runtime(files: list<string>) {
    if(files.size() == 0) {
       error("no files were found to be compiled, have you excluded your project directory by chance?");
    }

    if(options.green_mode) {
        throttle_max_threads();
    }

    test_file := new file(files.at(0));
    tokens := test_file.read();
    tok := new tokenizer(tokens, files.at(0));
    tok.get_errors().print_errors();
    parse("test.json");
    //Parser parser = new Parser(tokenizer);
    //parser.atErrors().printErrors();
}


private def create_project() {
    dir := new file(options.new_project_dir);

    try{
       if(dir.exists()) {
             println("could not create project, a ${dir.is_directory() ? "directory" : "file"} with the name ${options.new_project_dir} already exists!");
             exit(1);
       }

       if(dir.mkdir() != 0) {
          println("failed to create project directory: ${options.new_project_dir}");
          exit(1);
       }

       src_dir := new file(options.new_project_dir + "/src/");
       build_dir := new file(options.new_project_dir + "/build/");
       cache_dir := new file(options.new_project_dir + "/build/cache/");
       outputs_dir := new file(options.new_project_dir + "/build/outputs/");
       files_dir := new file(options.new_project_dir + "/build/cache/files/");

       if(src_dir.mkdir() || build_dir.mkdir() || cache_dir.mkdir()
          || outputs_dir.mkdir() || files_dir.mkdir()) {
          println("failed to create all necessary directories for project: ${options.new_project_dir}");
          exit(1);
       }

       main_template_file : file;
       settings_template_file : file;
       main_file := new file(options.new_project_dir + "/src/main.sharp");
       settings_file := new file(options.new_project_dir + "/settings.json");

       if(build.is_windows()) {
          main_template_file = new file("C:\\Program Files\\Sharp\\proj-template\\main.sharp");
          settings_template_file = new file("C:\\Program Files\\Sharp\\proj-template\\settings.json");
       } else {
          main_template_file = new file("/usr/include/sharp/proj-template/main.sharp");
          settings_template_file = new file("/usr/include/sharp/settings.json");
       }

       data : string = "";
       if(main_template_file.exists()) {
          data = main_template_file.read();
       } else {
         data = "mod main;\n\ndef main() {\n  println(\"hello, world!\");\n}\n";
       }

       if(main_file.write(data) != 0) {
          println("failed to create the main file for project: ${dir.get_name()}");
          exit(1);
       }

       if(settings_template_file.exists()) {
           data = settings_template_file.read();
       } else {
           data = "{\n  name: \"${dir.get_name()}\",\n  version: \"1.0\",\n  output: \"${dir.get_name()}\",\n"
              + "ignore_folders: [\n     \"build\"\n  ]\n}\n";
       }

       if(settings_file.write(data) != 0) {
          println("failed to create the main file for project: ${dir.get_name()}");
          exit(1);
       }
    } catch(t: throwable) {
          println("failed to create all necessary directories for project: ${options.new_project_dir}. Error: ${t.get_message()}");
          exit(1);
    }

    println("Project: \"${dir.get_name()}\" successfully created!");
    exit();
}

private static def is_number(str: string) : var {
    foreach(c in str) {
        if(!char.is_digit(c))
            return false;
    }
    return true;
}

private static def check_target() {
    when(options.target) {
        main#platform.alpha -> {
            return;
        }
        else -> {
            error("invalid platform target `${options.target}`");
        }
    }
}

def error(message: string) {
    println("$program_name:  error: $message");
    exit();
}

private static def print_version() {
    print(program_name + " " + program_vers);
}

private static def help() {
    println("Usage: sharpc " + "{OPTIONS} SOURCE FILE(S)");
    println("Source file must have a .sharp extension to be compiled.\n");
    println("[-options]\n\n    -V                print compiler version and exit");
    println(              "    -showvers         print compiler version and continue"               );
    println(              "    -o<file>          set the output object file"                        );
    println(              "    -c                compile only and do not generate exe"              );
    println(              "    -a                enable aggressive error reporting"                 );
    println(              "    -s                strip debugging info"                              );
    println(              "    -O -O1            optimize code level 1"                             );
    println(              "    -O2               optimize code level 2"                             );
    println(              "    -L<path>          library directory path"                            );
    println(              "    -w                disable all warnings"                              );
    println(              "    -run              run compiled source after successful compilation"  );
    println(              "    -g -green         run compiler in \"green\" mode to consume less power");
    println(              "    -ignoredir<dir>   include a directory to ignore (only works in project mode)");
    println(              "    -ignore<file>     include a file to ignore"                          );
    println(              "    -p                enable project mode compilation"                   );
    println(              "    -P<path>          enable project mode compilation on a specific path");
    println(              "    --new-project<name> create a new sharp project"                      );
    println(              "    -errlmt<count>    set max errors the compiler allows before quitting");
    println(              "    -v<version>       set the application version"                       );
    println(              "    -target           target the specified platform of sharp to run on"  );
    println(              "    -release -r       generate a release build exe"                      );
    println(              "    --hw               display help message for warning options"         );
    println(              "    --h -?             display this help message"                        );
}

private static def help_warning() {
    println( "Usage: sharpc {OPTIONS} SOURCE FILE(S)");
    println( "Source file must have a .sharp extion to be compiled.\n");
    println( "Please note that not all warnings will be able to be disabled individually.\n");
    println( "[-options]\n\n    -w                disable all warnings"                                     );
    println(               "    -winit            disable class initialization warnings"                    );
    println(               "    -waccess          disable access modifier warnings (public, static, etc.)"  );
    println(               "    -wambig           disable ambiguous symbol warnings"                        );
    println(               "    -wdecl            disable object declaration warnings"                      );
    println(               "    -wmain            disable multiple main method warnings"                    );
    println(               "    -wcast            disable type cast warnings"                               );
    println(               "    -werror           enable warnings as errors"                                );
    println(               "    --hw               display this help message"                               );
}
